[{"id":"t_3f60cfb2af2e4c5e86dadfc7df8eb843","oldText":"User Defined Functions","tlText":"用户定义函数","version":0},{"id":"t_cab37cbb61be48d4a672dfee052e1c74","oldText":"How to Create and Use User Defined Functions","tlText":"如何创建和使用用户定义的函数","version":0},{"id":"t_13851b7072dd45908e8562e06138cc09","oldText":"Description","tlText":"描述","version":0},{"id":"t_7d43328137214b0d9ad03359f3e75472","oldText":"An Example","tlText":"一个例子","version":0},{"id":"t_f2329312af7342b2aa45c322187e4ad1","oldText":"Defining Your Function","tlText":"定义你的功能","version":0},{"id":"t_54d9bfae3f914b1da65f00718f6fb2a4","oldText":"Registering Your Function","tlText":"注册你的函数","version":0},{"id":"t_4e562bc002fc4e4a94ec4d2e9667363b","oldText":"This document describes the User Defined Functions within POI. User defined functions allow you to take code that is written in VBA and re-write in Java and use within POI. Consider the following example.","tlText":"本文档描述 POI 中的用户定义函数。用户定义的函数允许您获取用 VBA 编写的代码并用 Java 重写并在 POI 中使用。考虑以下示例。","version":0},{"id":"t_f2f730e0db224abf92ea85f1a83183e9","oldText":"Suppose you are given a spreadsheet that can calculate the principal and interest payments for a mortgage. The user enters the principal loan amount, the interest rate and the term of the loan. The Excel spreadsheet does the rest.","tlText":"假设您有一个可以计算抵押贷款的本金和利息支付的电子表格。用户输入本金贷款金额、利率和贷款期限。 Excel 电子表格会完成余下的工作。","version":0},{"id":"t_0678610824144a44b24097c0a9a93fc1","oldText":"When you actually look at the workbook you discover that rather than having the formula in a cell it has been written as VBA function. You review the function and determine that it could be written in Java:","tlText":"当您实际查看工作簿时，您会发现它不是将公式放在单元格中，而是将其编写为 VBA 函数。您查看该函数并确定它可以用 Java 编写：","version":0},{"id":"t_a7b16dd5d3ec42a78b7153ae5f616866","oldText":"If we write a small program to try to evaluate this cell, we\u0027ll fail. Consider this source code:","tlText":"如果我们编写一个小程序来尝试评估这个单元格，我们将会失败。考虑这个源代码：","version":0},{"id":"t_e04e74426a2a4b4aa89d95780bacaea0","oldText":"If you run this code, you\u0027re likely to get the following error:","tlText":"如果您运行此代码，您可能会收到以下错误：","version":0},{"id":"t_42df85f6ae3642f682f7206c6dbba6a9","oldText":"How would we make it so POI can use this sheet?","tlText":"我们将如何制作它以便 POI 可以使用此表？","version":0},{"id":"t_6a5b10aafeb24220aa660d2830ed7577","oldText":"To \u0027convert\u0027 this code to Java and make it available to POI you need to implement a FreeRefFunction instance. FreeRefFunction is an interface in the org.apache.poi.ss.formula.functions package. This interface defines one method, evaluate(ValueEval[] args, OperationEvaluationContext ec), which is how you will receive the argument values from POI.","tlText":"要将此代码“转换”为 Java 并使其可用于 POI，您需要实现一个 FreeRefFunction 实例。 FreeRefFunction 是 org.apache.poi.ss.formula.functions 包中的一个接口。该接口定义了一种方法，evaluate(ValueEval[] args, OperationEvaluationContext ec)，这是您从 POI 接收参数值的方式。","version":0},{"id":"t_bde05d62d29349d2b126f6b52f5de33a","oldText":"The evaluate() method as defined above is where you will convert the ValueEval instances to the proper number types. The following code snippet shows you how to get your values:","tlText":"上面定义的 evaluate() 方法用于将 ValueEval 实例转换为正确的数字类型。以下代码片段向您展示了如何获取您的值：","version":0},{"id":"t_ba0c051ab1a74d1ba045c59fc37d4fc7","oldText":"The first thing we do is check the number of arguments being passed since there is no sense in attempting to go further if you are missing critical information.","tlText":"我们要做的第一件事是检查传递的参数的数量，因为如果您丢失了关键信息，那么尝试更进一步是没有意义的。","version":0},{"id":"t_206283609ceb4bdeb33f6e32023943a1","oldText":"Next we declare our variables, in our case we need variables for:","tlText":"接下来我们声明我们的变量，在我们的例子中，我们需要以下变量：","version":0},{"id":"t_9ce21feb483b401d971785d7bbf8f66d","oldText":"Next, we use the OperandResolver to convert the ValueEval instances to doubles, though not directly. First we start by getting discreet values. Using the OperandResolver.getSingleValue() method we retrieve each of the values passed in by the cell in the spreadsheet. Next, we use the OperandResolver again to convert the ValueEval instances to doubles, in this case. This class has other methods of coercion for getting Strings, ints and booleans. Now that we\u0027ve got our primitive values we can move on to calculating the value.","tlText":"接下来，我们使用 OperandResolver 将 ValueEval 实例转换为双精度值，尽管不是直接的。首先，我们从获取谨慎的值开始。使用 OperandResolver.getSingleValue() 方法，我们检索电子表格中单元格传入的每个值。接下来，在本例中，我们再次使用 OperandResolver 将 ValueEval 实例转换为双精度值。这个类还有其他获取字符串、整数和布尔值的强制方法。现在我们已经获得了原始值，我们可以继续计算该值。","version":0},{"id":"t_e43bd07265c34272a5892dcd9b036854","oldText":"As shown previously, we have the VBA source. We need to add code to our class to calculate the payment. To do this you could simply add it to the method we\u0027ve already created but I\u0027ve chosen to add it as its own method. Add the following method:","tlText":"如前所示，我们有 VBA 源代码。我们需要在我们的类中添加代码来计算付款。为此，您可以简单地将其添加到我们已经创建的方法中，但我选择将其添加为自己的方法。添加以下方法：","version":0},{"id":"t_70a72a596ca548ecafa020b5b66b75c9","oldText":"The biggest change necessary is related to the exponents; Java doesn\u0027t have a notation for this so we had to add calls to Math.pow(). Now we need to add this call to our previous method:","tlText":"最大的必要变化与指数有关； Java 对此没有表示法，因此我们必须添加对 Math.pow() 的调用。现在我们需要将此调用添加到我们之前的方法中：","version":0},{"id":"t_8dfe4746fc9f4886bb76bf932b1ff06f","oldText":"Having done that, the last things we need to do are to check to make sure we didn\u0027t get a bad result and, if not, we need to return the value. Add the following code to the class:","tlText":"完成后，我们需要做的最后一件事是检查以确保我们没有得到错误的结果，如果没有，我们需要返回值。将以下代码添加到类中：","version":0},{"id":"t_264a153220614f29b095c76f9d738578","oldText":"Then add a line of code to our evaluate method to call this new static method, complete our try/catch and return the value:","tlText":"然后在我们的评估方法中添加一行代码来调用这个新的静态方法，完成我们的try/catch并返回值：","version":0},{"id":"t_3ec77ac2d9c94a0aace903eb6a78319f","oldText":"So the whole class would be as follows:","tlText":"所以整个类如下：","version":0},{"id":"t_94f5e37fb64e45589008689dffa447ad","oldText":"Great! Now we need to go back to our original program that failed to evaluate our cell and add code that will allow it run our new Java code.","tlText":"伟大的！现在我们需要回到未能评估我们的单元的原始程序，并添加允许它运行我们新的 Java 代码的代码。","version":0},{"id":"t_0695b640be62470fabdcd360c0c05dd1","oldText":"Now we need to register our function in the Workbook, so that the Formula Evaluator can resolve the name \"calculatePayment\" and map it to the actual implementation (CalculateMortgage). This is done using the UDFFinder object. The UDFFinder manages FreeRefFunctions which are our analogy for the VBA code. We need to create a UDFFinder. There are a few things we need to know in order to do this:","tlText":"现在我们需要在 Workbook 中注册我们的函数，以便 Formula Evaluator 可以解析名称“calculatePayment”并将其映射到实际执行中（CalculateMortgage）。这是使用 UDFFinder 对象完成的。 UDFFinder 管理 FreeRefFunctions，这是我们对 VBA 代码的类比。我们需要创建一个 UDFFinder。为了做到这一点，我们需要知道一些事情：","version":0},{"id":"t_798a770054f84756bb586a0cb9e21e5f","oldText":"UDFFinder is actually an interface, so we need to use an actual implementation of this interface. Therefore we use the org.apache.poi.ss.formula.udf.DefaultUDFFinder class. If you refer to the Javadocs you\u0027ll see that this class expects to get two arrays, one containing the alias and the other containing an instance of the class that will represent that alias. In our case our alias will be calculatePayment and our class instance will be of the CalculateMortgage type. This class needs to be available at compile and runtime. Be sure to keep these arrays well organized because you\u0027ll run into problems if these arrays are of different sizes or the alias aren\u0027t in the same relative position in their respective arrays. Add the following code:","tlText":"UDFFinder 实际上是一个接口，所以我们需要使用这个接口的实际实现。因此我们使用 org.apache.poi.ss.formula.udf.DefaultUDFFinder 类。如果您参考 Javadocs，您会看到该类期望获得两个数组，一个包含别名，另一个包含将表示该别名的类的实例。在我们的例子中，我们的别名是calculatePayment，我们的类实例是CalculateMortgage 类型。此类需要在编译和运行时可用。请务必保持这些数组井井有条，因为如果这些数组的大小不同或别名在各自数组中的相对位置不同，您会遇到问题。添加以下代码：","version":0},{"id":"t_736ffa68a5f84c2d95f2b84bfce84417","oldText":"Now we have our UDFFinder instance and we\u0027ve created the AggregatingUDFFinder instance. The last step is to pass this to our Workbook:","tlText":"现在我们有了 UDFFinder 实例，并且创建了 AggregatingUDFFinder 实例。最后一步是将其传递给我们的工作簿：","version":0},{"id":"t_91bc1d484ac3476ab34378bcc3570558","oldText":"So now the whole class will look like this:","tlText":"所以现在整个类看起来像这样：","version":0},{"id":"t_486f334fc8fc4dbc8ea7db6732d4587b","oldText":"Now that our evaluator is aware of the UDFFinder which in turn is aware of our FreeRefFunction, we\u0027re ready to re-run our example:","tlText":"现在我们的求值器知道了 UDFFinder，而 UDFFinder 又知道了我们的 FreeRefFunction，我们准备重新运行我们的示例：","version":0},{"id":"t_d3db295ccbcd4130ab8479a7e9df3181","oldText":"which prints the following output in the console:","tlText":"在控制台中打印以下输出：","version":0},{"id":"t_bd9302408d7344d7954955dcdef3e10c","oldText":"That is it! Now you can create Java code and register it, allowing your POI based appliction to run spreadsheets that previously were inaccessible.","tlText":"这就对了！现在您可以创建 Java 代码并注册，从而允许基于 POI 的应用程序运行以前无法访问的电子表格。","version":0},{"id":"t_ac3ea7598d544d9e8c3cedfdacce15de","oldText":"This example can be found in the src/examples/src/org/apache/poi/examples/ss/formula folder in the source.","tlText":"此示例可以在源代码的 src/examples/src/org/apache/poi/examples/ss/formula 文件夹中找到。","version":0},{"id":"t_29ae26dc7b294dd88dd353276031857d","oldText":"by Jon Svede, Brian Bush","tlText":"作者：乔恩·斯维德、布赖恩·布什","version":0},{"id":"t_4b4e78cbff2e4983b9e54ef3c28e327a","oldText":"principal - the amount of the loan","tlText":"本金 - 贷款金额","version":0},{"id":"t_7b85506b437644668b746d83dfa6759f","oldText":"rate - the interest rate as a decimal","tlText":"rate - 小数形式的利率","version":0},{"id":"t_67b0efb5737042498dc26fde8f14e026","oldText":"years - the length of the loan in years","tlText":"年 - 贷款的年限","version":0},{"id":"t_5f73842ff4ba414291dba4831af58b4c","oldText":"result - the result of the calculation","tlText":"result - 计算的结果","version":0},{"id":"t_0b1da8ca14b34d4abded137f85630dc2","oldText":"The name of the function in the VBA code (in our case it is calculatePayment)","tlText":"VBA 代码中函数的名称（在我们的例子中是 calculatePayment）","version":0},{"id":"t_d91d089e1da0417e9d6efd7a42874c6e","oldText":"The Class name of our FreeRefFunction","tlText":"我们的 FreeRefFunction 的类名","version":0},{"id":"t_b094c0f1f2cd4520bdca8a38efdc8792","oldText":"/**\r\n* A simple function to calculate principal and interest.\r\n*\r\n* @author Jon Svede\r\n*\r\n*/\r\n","tlText":"/**\r\n* 计算本金和利息的简单函数。\r\n*\r\n* @作者乔恩·斯维德\r\n*\r\n*/\r\n","version":0},{"id":"t_f5bc7df2b6d8468e9c24ecc67aca1dbd","oldText":"//M \u003d P [ i(1 + i)n ] / [ (1 + i)n - 1]\r\n","tlText":"//M \u003d P [ i（1 + i）n ] / [（1 + i）n - 1]\r\n","version":0},{"id":"t_acb9ea3671bf4cf89fee91c0d58f3283","oldText":"/**\r\n* Excel does not support infinities and NaNs, rather, it gives a #NUM! error in these cases\r\n*\r\n* @throws EvaluationException (#NUM!) if \u003ctt\u003eresult\u003c/tt\u003e is \u003ctt\u003eNaN\u003c/\u003e or \u003ctt\u003eInfinity\u003c/tt\u003e\r\n*/\r\n","tlText":"/**\r\n* Excel不支持无穷大和NaN，而是提供#NUM！在这些情况下的错误\r\n*\r\n* @throws EvaluationException（#NUM！）如果\u003ctt\u003e结果\u003c/tt\u003e为\u003ctt\u003eNaN\u003c/\u003e或\u003ctt\u003eInfinity\u003c/tt\u003e\r\n*/\r\n","version":0}]