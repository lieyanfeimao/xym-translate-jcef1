[{"id":"t_57c114fb048b436e8b101d5076ec6a9d","oldText":"Developing Formula Evaluation","tlText":"公式求值开发","version":0},{"id":"t_b4e0f4a7e9ed44c48f819a2144557833","oldText":"Introduction","tlText":"介绍","version":0},{"id":"t_a5a68e9c57a04a5a8508d3d7e569294e","oldText":"Overview of FormulaEvaluator","tlText":"FormulaEvaluator 概述","version":0},{"id":"t_631e8292fcb248c5871d262bc1965c31","oldText":"What functions are supported?","tlText":"支持哪些功能？","version":0},{"id":"t_1e9443bbae9541a7b0bd5197644aa052","oldText":"Two base interfaces to start your implementation","tlText":"两个基本接口来开始你的实现","version":0},{"id":"t_d9bec27565d4404eabeb77b49d0b961c","oldText":"Which interface to start from?","tlText":"从哪个接口开始？","version":0},{"id":"t_4e3f13207897476e89ef3fdb65ce1966","oldText":"Walkthrough of an \"evaluate()\" implementation.","tlText":"“evaluate()”实现的演练。","version":0},{"id":"t_5d9e1264d1f143ae9723181df9ca9834","oldText":"Floating-point Arithmetic in Excel","tlText":"Excel中的浮点运算","version":0},{"id":"t_c67ea0d468ab45afba415fe2d2ed4ca9","oldText":"Testing Framework","tlText":"测试框架","version":0},{"id":"t_1a717eda64544952831f67bb2969b85d","oldText":"Appendix A","tlText":"附录 A","version":0},{"id":"t_1b15c98022f442c1806d51ffa88ecb50","oldText":"The big picture","tlText":"大图","version":0},{"id":"t_da8dbac6652a402aaf0abbdbcd4e71d1","oldText":"This document is for developers wishing to contribute to the FormulaEvaluator API functionality.","tlText":"本文档适用于希望为 FormulaEvaluator API 功能做出贡献的开发人员。","version":0},{"id":"t_e01e6dbeef304f46bfbdbe1bb92f2f04","oldText":"When evaluating workbooks you may encounter a org.apache.poi.ss.formula.eval.NotImplementedException which indicates that a function is not (yet) supported by POI. Is there a workaround? Yes, the POI framework makes it easy to add implementation of new functions. Prior to POI-3.8 you had to checkout the source code from svn and make a custom build with your function implementation. Since POI-3.8 you can register new functions in run-time.","tlText":"在对工作簿进行公式求值时，您可能会遇到org.apache.poi.ss.formula.eval.NotImplementedException，这表示 POI（尚不）支持某个函数。有解决方法吗？是的，POI 框架可以轻松添加新函数的实现。在 POI-3.8 之前，您必须从svn检出源代码并使用您的函数实现进行自定义构建。从 POI-3.8 开始，您可以在运行时注册新函数。","version":0},{"id":"t_9039705885e6477cbb001928ca54db14","oldText":"Currently, contribution is desired for implementing the standard MS excel functions. Place holder classes for these have been created, contributors only need to insert implementation for the individual \"evaluate()\" methods that do the actual evaluation.","tlText":"目前，我们已经为想给实现标准的MS excel函数做出贡献的靓仔创建了占位符类，贡献者只需要提供执行实际求值的各个“evaluate()”方法的实现。","version":0},{"id":"t_64b91300ec084fc49fc60ef99389ccce","oldText":"Briefly, a formula string (along with the sheet and workbook that form the context in which the formula is evaluated) is first parsed into RPN tokens using the FormulaParser class . (If you don\u0027t know what RPN tokens are, now is a good time to read this.)","tlText":"简而言之，第一步是使用FormulaParser类将公式字符串（以及构成公式计算环境的工作表和工作簿）解析为 RPN 标记。 （如果您不知道什么是RPN令牌，现在是阅读\u003ca href\u003d\"http://www-stone.ch.cam.ac.uk/documentation/rrf/rpn.html\" style\u003d\"color:blue;\" target\u003d\"_blank\"\u003e这篇文章\u003c/a\u003e的好时机。）","version":0},{"id":"t_752bdd22865a432681419ddb55a1501f","oldText":"RPN tokens are mapped to Eval classes. (Class hierarchy for the Evals is best understood if you view the class diagram in a class diagram viewer.) Depending on the type of RPN token (also called as Ptgs henceforth since that is what the FormulaParser calls the classes) a specific type of Eval wrapper is constructed to wrap the RPN token and is pushed on the stack.... UNLESS the Ptg is an OperationPtg. If it is an OperationPtg, an OperationEval instance is created for the specific type of OperationPtg. And depending on how many operands it takes, that many Evals are popped of the stack and passed in an array to the OperationEval instance\u0027s evaluate method which returns an Eval of subtype ValueEval.Thus an operation in the formula is evaluated.","tlText":"RPN 令牌映射到 Eval 类。（如果您在类图查看器中查看类图，则可以更好地理解 Eval 的类层次结构）根据 RPN 标记的类型（此后也称为Ptgs，因为在FormulaParser里是这样命名的），特定类型的 Eval wrapper 用于包装 RPN 令牌并被压入堆栈......除非 Ptg 是 OperationPtg。如果是 OperationPtg，则为特定类型的 OperationPtg 创建一个 OperationEval 实例。并且根据它需要多少个操作数，许多 Eval 会从堆栈中弹出并以数组的形式传递给 OperationEval 实例的求值方法，该方法返回一个Eval的子类型ValueEval。这便是一个公式的求值操作。","version":0},{"id":"t_53f1a8388aa9490cabdadfef62e7244d","oldText":"OperationEval.evaluate(Eval[]) returns an Eval which is supposed to be of type ValueEval (actually since ValueEval is an interface, the return value is instance of one of the implementations of ValueEval). The valueEval resulting from evaluate() is pushed on the stack and the next RPN token is evaluated.... this continues till eventually there are no more RPN tokens at which point, if the formula string was correctly parsed, there should be just one Eval on the stack - which contains the result of evaluating the formula.","tlText":"OperationEval.evaluate(Eval[]) 返回一个 Eval，它应该是 ValueEval 类型（实际上，由于ValueEval是一个接口，所以返回值是实现了ValueEval接口的实例）。从 evaluate() 产生的valueEval被推入堆栈并求值下一个RPN令牌......这种情况一直持续到最终不再有RPN标记，如果公式字符串被正确解析，堆栈上应该只有一个的Eval-它包含计算公式的结果。","version":0},{"id":"t_aa7cca1e151a44ad82d9130b21922e3c","oldText":"Of course I glossed over the details of how AreaPtg and ReferencePtg are handled a little differently, but the code should be self explanatory for that. Very briefly, the cells included in AreaPtg and RefPtg are examined and their values are populated in individual ValueEval objects which are set into the AreaEval and RefEval (ok, since AreaEval and RefEval are interfaces, the implementations of AreaEval and RefEval - but you\u0027ll figure all that out from the code)","tlText":"当然，我对AreaPtg和ReferencePtg的处理方式略有不同的细节略作掩饰，但代码对此应该不言自明。简单地说，检查AreaPtg和RefPtg中包含的单元格，并将它们的值填充到各个ValueEval对象中，这些对象被设置为AreaEval和RefEval（因为 AreaEval 和 RefEval 是接口，所以AreaEval 和 RefEval 的实现 - 你能从代码中弄清楚这些）","version":0},{"id":"t_ec5e5b14cabc4b188dc9119b1b4a923c","oldText":"OperationEvals for the standard operators have been implemented and tested.","tlText":"标准运算符的 OperationEvals 已经实施和测试。","version":0},{"id":"t_986fcedd7a9f4e33bc64250ce7255761","oldText":"As of September 2017, POI supports about 176 built-in functions, see Appendix A for the full list. You can programmatically list supported / unsupported functions using the following helper methods:","tlText":"截至2017年9月，POI支持大约176个内置函数，完整列表见\u003ca href\u003d\"#appendixA\" style\u003d\"color:blue\"\u003e附录 A\u003c/a\u003e。您可以使用以下方法列出支持/不支持的函数：","version":0},{"id":"t_4c106fe399ff46c4b66e123509b90bc8","oldText":"All Excel formula function classes implement either org.apache.poi.hssf.record.formula.functions.Function or org.apache.poi.hssf.record.formula.functions.FreeRefFunction interface. Function is a common interface for the functions defined in the binary Excel format (BIFF8): these are \"classic\" Excel functions like SUM, COUNT, LOOKUP, etc. FreeRefFunction is a common interface for the functions from the Excel Analysis Toolpack and for User-Defined Functions. In the future these two interfaces are expected be unified into one, but for now you have to start your implementation from two slightly different roots.","tlText":"所有 Excel 公式函数类都实现 org.apache.poi.hssf.record.formula.functions.Function 或 org.apache.poi.hssf.record.formula.functions.FreeRefFunction 接口。 Function 是以二进制 Excel 格式 (BIFF8) 定义的函数的通用接口：这些“经典” Excel 函数，如 SUM、COUNT、LOOKUP 等。FreeRefFunction是Excel分析工具包中的函数和用户定义函数的通用接口。将来这两个接口有望统一为一个，但现在您必须从两个稍微不同的根源开始实现。","version":0},{"id":"t_1395b3d85755437884be0ad3c4d86f22","oldText":"You are about to implement a function XXX and don\u0027t know which interface to start from: Function or FreeRefFunction. Use the following code to check whether your function is from the excel Analysis Toolpack:","tlText":"你即将实现一个函数 XXX，而不知道从Function 或 FreeRefFunction哪个接口开始。使用以下代码检查您的函数是否来自excel分析工具包：","version":0},{"id":"t_3e40ac8830c94ed3b0a09e462ffed822","oldText":"Here is the fun part: lets walk through the implementation of the excel function SQRT()","tlText":"这是有趣的部分：让我们来看看 excel 函数 SQRT() 的实现","version":0},{"id":"t_255441c0be054dbbbb9f406fa6ea630e","oldText":"AnalysisToolPack.isATPFunction(\"SQRTPI\") returns false so the base interface is Function. There are sub-interfaces that make life easier when implementing numeric functions or functions with fixed number of arguments, 1-arg, 2-arg and 3-arg function:","tlText":"AnalysisToolPack.isATPFunction(\u0026quot;SQRTPI\u0026quot;) 返回 false，因此基本接口是 Function。在实现数值函数或具有固定参数数的函数、1-arg、2-arg和3-arg函数时，有一些子接口可以简化工作：","version":0},{"id":"t_0e65c70020504d54a29d367ccb1ec2ae","oldText":"Since SQRTPI takes exactly one argument we start our implementation from org.apache.poi.hssf.record.formula.functions.Fixed1ArgFunction:","tlText":"由于 SQRTPI 只采用一个参数，我们用org.apache.poi.hssf.record.formula.functions.Fixed1ArgFunction开始我们的实现：","version":0},{"id":"t_8630686f625c4da3aa56dcf2472633e1","oldText":"Now when the implementation is ready we need to register it in the formula evaluator:","tlText":"现在，当实现准备就绪时，我们需要在公式求值器中注册它：","version":0},{"id":"t_dcdd558f5a304238bfe4c057e0ba7fa1","oldText":"Voila! The formula evaluator now recognizes SQRTPI!","tlText":"瞧！公式求值器现在可以识别 SQRTPI！","version":0},{"id":"t_996d905a82304166964f996aa03b454b","oldText":"Excel uses the IEEE Standard for Double Precision Floating Point numbers except two cases where it does not adhere to IEEE 754:","tlText":"Excel对双精度浮点数使用IEEE标准，但有两种情况不符合IEEE 754：","version":0},{"id":"t_fa9d7ff25ba34f89a0c6425c21e727f4","oldText":"Be aware of these two cases when saving results of your scientific calculations in Excel: “where are my Infinities and NaNs? They are gone!”","tlText":"在 Excel 中保存科学计算结果时请注意以下两种情况：“我的无穷大和 NaN 在哪里？他们走了！”","version":0},{"id":"t_a50ff20c7ea34a3b8aab741a14bf08e3","oldText":"Automated testing of the implemented Function is easy. The source code for this is in the file: o.a.p.h.record.formula.GenericFormulaTestCase.java This class has a reference to the test xls file (not /a/ test xls, /the/ test xls :) which may need to be changed for your environment. Once you do that, in the test xls, locate the entry for the function that you have implemented and enter different tests in a cell in the FORMULA row. Then copy the \"value of\" the formula that you entered in the cell just below it (this is easily done in excel as: [copy the formula cell] \u003e [go to cell below] \u003e Edit \u003e Paste Special \u003e Values \u003e \"ok\"). You can enter multiple such formulas and paste their values in the cell below and the test framework will automatically test if the formula evaluation matches the expected value (Again, hard to put in words, so if you will, please take time to quickly look at the code and the currently entered tests in the patch attachment \"FormulaEvalTestData.xls\" file).","tlText":"实现函数的自动化测试很容易。源代码在o.a.p.h.record.formula.GenericFormulaTestCase.java文件中。 此类引用了test xls文件（不是 /a/test xls，/the/test xls :)，您可能需要根据您的环境更改该文件。完成此操作后，在test xls 中，找到您已实现的函数的条目，并在公式行的单元格中输入不同的测试。然后复制您在其下方单元格中输入的公式的“值”（这在 excel 中很容易完成，如下所示：[复制公式单元格]\u0026gt;[转到下面的单元格]\u0026gt;编辑\u0026gt;选择性粘贴\u0026gt;值\u0026gt;“确定”）。您可以输入多个这样的公式并将它们的值粘贴到下面的单元格中，测试框架会自动测试公式求值是否与预期值匹配（再次，很难用语言表达，所以如果您愿意，请花点时间快速查看补丁附件“FormulaEvalTestData.xls”文件中的代码和当前输入的测试）。","version":0},{"id":"t_82bcd160b0894102bc5524b3a90f8a18","oldText":"Functions supported by POI (as of September 2017)","tlText":"POI支持的函数（截至2017年9月）","version":0},{"id":"t_a83059f9e39045f390980cb9722b3214","oldText":"by Amol Deshmukh, Yegor Kozlov","tlText":"作者：Amol Deshmukh，叶戈尔·科兹洛夫","version":0},{"id":"t_f9d7f48dd4fb497eaf7d880f8d86acec","oldText":"org.apache.poi.hssf.record.formula.functions.NumericFunction","tlText":"org.apache.poi.hssf.record.formula.functions.NumericFunction","version":0},{"id":"t_8c1c203d6d0145ee81296219a70a63b9","oldText":"org.apache.poi.hssf.record.formula.functions.Fixed1ArgFunction","tlText":"org.apache.poi.hssf.record.formula.functions.Fixed1ArgFunction","version":0},{"id":"t_8709f195032044c28c98e9c7033d3690","oldText":"org.apache.poi.hssf.record.formula.functions.Fixed2ArgFunction","tlText":"org.apache.poi.hssf.record.formula.functions.Fixed2ArgFunction","version":0},{"id":"t_8783e04cd2c24f05b2c64221bb0df3fd","oldText":"org.apache.poi.hssf.record.formula.functions.Fixed3ArgFunction","tlText":"org.apache.poi.hssf.record.formula.functions.Fixed3ArgFunction","version":0},{"id":"t_7fd35793054e4b33aee034da21cffb56","oldText":"org.apache.poi.hssf.record.formula.functions.Fixed4ArgFunction","tlText":"org.apache.poi.hssf.record.formula.functions.Fixed4ArgFunction","version":0},{"id":"t_099749cd507c4a888d8897974a41e962","oldText":"Positive/Negative Infinities: Infinities occur when you divide by 0. Excel does not support infinities, rather, it gives a #DIV/0! error in these cases.","tlText":"正/负无穷大：除以 0 时出现无穷大。Excel 不支持无穷大，而是给出 #DIV/0！在这种情况下会出现错误。","version":0},{"id":"t_2e42a139b0044dc1a8008d448aa5dcf7","oldText":"Not-a-Number (NaN): NaN is used to represent invalid operations (such as infinity/infinity, infinity-infinity, or the square root of -1). NaNs allow a program to continue past an invalid operation. Excel instead immediately generates an error such as #NUM! or #DIV/0!.","tlText":"Not-a-Number (NaN)：NaN 用于表示无效运算（如无穷大/无穷大、无穷-无穷大或-1 的平方根）。NAN允许程序继续执行无效操作，相反，Excel 会立即生成错误，例如 #NUM！或#DIV/0！。","version":0},{"id":"t_b4c540d7b9d74114992456d4312780b7","oldText":"An Eval is of subinterface ValueEval or OperationEval. Operands are always ValueEvals, Operations are always OperationEvals.","tlText":"Eval的子接口ValueEval或OperationEval。操作数始终是 ValueEval，操作始终是 OperationEval。","version":0},{"id":"t_25d3a61ae9fc431e9b19c75c999c93ce","oldText":"Note","tlText":"笔记","version":0},{"id":"t_18af6150db6e47ee8d38db7a08b55b8a","oldText":"// list of functions that POI can evaluate\r\n","tlText":"//兴趣点可以评估的功能列表\r\n","version":0},{"id":"t_97ca3a2065694aab8061cb09e58f532b","oldText":"// list of functions that are not supported by POI\r\n","tlText":"//不受兴趣点支持的功能列表\r\n","version":0},{"id":"t_3056ae0c3a1746119e5c55b9a7c1a747","oldText":"// the function implements org.apache.poi.hssf.record.formula.functions.Function\r\n","tlText":"//该函数实现org.apache.poi.hssf.record.formula.functions. Value\r\n","version":0},{"id":"t_9d7603a425de48318294386630107e91","oldText":"// the function implements org.apache.poi.hssf.record.formula.functions.FreeRefFunction\r\n","tlText":"//该函数实现org.apache.poi.hssf.record.formula.functions. FreeRefUnity\r\n","version":0},{"id":"t_d6bb2d6a64484d8e8820874b080aee53","oldText":"// Retrieves a single value from a variety of different argument types according to standard\r\n// Excel rules. Does not perform any type conversion.\r\n","tlText":"//根据标准从各种不同的参数类型中检索单个值\r\n// Excel规则。不执行任何类型转换。\r\n","version":0},{"id":"t_d1da8254b00841339bd74803fbbf81af","oldText":"// Applies some conversion rules if the supplied value is not already a number.\r\n// Throws EvaluationException(#VALUE!) if the supplied parameter is not a number\r\n","tlText":"//如果提供的值还不是数字，则卸载一些转换规则。\r\n//抛出评估异常（#UTE！）如果提供的参数不是数字\r\n","version":0},{"id":"t_7b7f55d1299d4eb89bd39bafb7db3e12","oldText":"// this where all the heavy-lifting happens\r\n","tlText":"//所有繁重的事情都发生在这里\r\n","version":0},{"id":"t_ab10778180904718b9bb8efca76d2e54","oldText":"// Excel uses the error code #NUM! instead of IEEE\r\n","tlText":"// Excel使用错误代码#NUM！而不是IEEE\r\n","version":0},{"id":"t_3b052ee07e7e4504b47415cf4ff931ff","oldText":"// so when a numeric function evaluates to Double.NaN or Double.Infinity,\r\n// be sure to translate the result to the appropriate error code\r\n","tlText":"//所以当数字函数的计算结果为Double.NaN或Double.Infinity时，\r\n//确保将结果翻译为适当的错误代码\r\n","version":0}]