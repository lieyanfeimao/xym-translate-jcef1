[{"id":"t_aae7b2e77a8b4f01a8798a743b3053ff","oldText":"POI-HSLF - A Guide to the PowerPoint File Format","tlText":"POI-HSLF - PowerPoint 文件格式指南","version":0},{"id":"t_8a8bf76e1d40404799484c20e75f712e","oldText":"Records, Containers and Atoms","tlText":"记录、容器和原子","version":0},{"id":"t_5e3bc366c9e746f594c3015370cccd5b","oldText":"Record Headers","tlText":"记录标题","version":0},{"id":"t_83799f0541e04355a0de3ddf16502162","oldText":"CurrentUserAtom, UserEditAtom and PersistPtrIncrementalBlock","tlText":"CurrentUserAtom、UserEditAtom 和 PersistPtrIncrementalBlock","version":0},{"id":"t_b563f30c3be448b3ae6833b1843f590c","oldText":"Paragraph and Text Styling","tlText":"段落和文本样式","version":0},{"id":"t_8bf18a9940174aa1848fbbc8efe0eb3c","oldText":"StyleTextPropAtom","tlText":"StyleTextPropAtom","version":0},{"id":"t_01b1b4e25e514c709a2eeff3bd642b0a","oldText":"Fonts in PowerPoint","tlText":"PowerPoint 中的字体","version":0},{"id":"t_0cbb5171471e48288aade02d1f8a3ba2","oldText":"FontEntityAtom","tlText":"字体实体原子","version":0},{"id":"t_da968fa9cbba453f9e7129d5fe2bde90","oldText":"Overview","tlText":"\u003cspan style\u003d\"color:black;\"\u003e概述\u003c/span\u003e","version":0},{"id":"t_d8262f78a2a5445396de900ce0c1fe7a","oldText":"PowerPoint documents are made up of a tree of records. A record may contain either other records (in which case it is a Container), or data (in which case it\u0027s an Atom). A record can\u0027t hold both.","tlText":"PowerPoint 文档由记录树组成。一条记录可能包含其他记录（在这种情况下它是一个容器）或数据（在这种情况下它是一个 Atom）。一个记录不能同时保存。","version":0},{"id":"t_9ee4549f603844278cc1c112e6d64519","oldText":"PowerPoint documents don\u0027t have one overall container record. Instead, there are a number of different container records to be found at the top level.","tlText":"PowerPoint 文档没有一个整体容器记录。相反，在顶层可以找到许多不同的容器记录。","version":0},{"id":"t_d3d5da123649475a8ddc5d276d14863f","oldText":"Any numbers or strings stored in the records are always stored in Little Endian format (least important bytes first). This is the case no matter what platform the file was written on - be that a Little Endian or a Big Endian system.","tlText":"存储在记录中的任何数字或字符串始终以 Little Endian 格式存储（最不重要的字节在前）。无论文件是在什么平台上编写的 - 无论是 Little Endian 还是 Big Endian 系统，情况都是如此。","version":0},{"id":"t_2b91662921ae4a2c8027c689146a22b4","oldText":"PowerPoint may have Escher (DDF) records embedded in it. These are always held as the children of a PPDrawing record (record type 1036). Escher records have the same format as PowerPoint records.","tlText":"PowerPoint 中可能嵌入了 Escher (DDF) 记录。这些始终作为 PPDrawing 记录（记录类型 1036）的子项保存。 Escher 记录与 PowerPoint 记录具有相同的格式。","version":0},{"id":"t_8585355f169a413189502e7f7bee1d4e","oldText":"All records, be they containers or atoms, have the same standard 8 byte header. It is:","tlText":"所有记录，无论是容器还是原子，都具有相同的标准 8 字节标头。它是：","version":0},{"id":"t_9cf988b2dfa348bca8cf49cbde33b357","oldText":"If the first byte of the header, BINARY_AND with 0x0f, is 0x0f, then the record is a container. Otherwise, it\u0027s an atom. The rest of the first two bytes are used to store the \"options\" for the record. Most commonly, this is used to indicate the version of the record, but the exact usage is record specific.","tlText":"如果标头的第一个字节 BINARY_AND 与 0x0f 是 0x0f，则记录是一个容器。否则，它是一个原子。前两个字节的其余部分用于存储记录的“选项”。最常见的是，这用于指示记录的版本，但确切的用法是特定于记录的。","version":0},{"id":"t_5cdbd529ed6944eeac07d0f35de921d1","oldText":"The record type is a little endian number, which tells you what kind of record you\u0027re dealing with. Each different kind of record has it\u0027s own value that gets stored here. PowerPoint records have a type that\u0027s normally less than 6000 (decimal). Escher records normally have a type between 0xF000 and 0xF1FF.","tlText":"记录类型是一个小端序号，它告诉您正在处理的记录类型。每种不同类型的记录都有自己存储在这里的价值。 PowerPoint 记录的类型通常小于 6000（十进制）。 Escher 记录的类型通常介于 0xF000 和 0xF1FF 之间。","version":0},{"id":"t_7e3adfa5464747c786a158048d029251","oldText":"The record length is another little endian number. For an atom, it\u0027s the size of the data part of the record, i.e. the length of the record less its 8 byte record header. For a container, it\u0027s the size of all the records that are children of this record. That means that the size of a container record is the length, plus 8 bytes for its record header.","tlText":"记录长度是另一个小端数。对于原子，它是记录的数据部分的大小，即记录的长度减去它的 8 字节记录头。对于容器，它是作为该记录子项的所有记录的大小。这意味着容器记录的大小是长度加上其记录头的 8 个字节。","version":0},{"id":"t_52d39d4783ec448fbf344f163beb867a","oldText":"aka Records that care about the byte level position of other records","tlText":"也就是关心其他记录的字节级位置的记录","version":0},{"id":"t_d36ae42190cc412182726959876d8246","oldText":"A small number of records contain byte level position offsets to other records. If you change the position of any records in the file, then there\u0027s a good chance that you will need to update some of these special records.","tlText":"少量记录包含到其他记录的字节级位置偏移。如果您更改文件中任何记录的位置，则很有可能需要更新其中一些特殊记录。","version":0},{"id":"t_323ff4c913af4deab0e1a11bb7585b16","oldText":"First up, CurrentUserAtom. This is actually stored in a different OLE2 (POIFS) stream to the main PowerPoint document. It contains a few bits of information on who lasted edited the file. Most importantly, at byte 8 of its contents, it stores (as a 32 bit little endian number) the offset in the main stream to the most recent UserEditAtom.","tlText":"首先，CurrentUserAtom。这实际上存储在与主 PowerPoint 文档不同的 OLE2 (POIFS) 流中。它包含一些关于谁最后编辑文件的信息。最重要的是，在其内容的第 8 个字节处，它将主流中的偏移量（作为 32 位小端数）存储到最近的 UserEditAtom。","version":0},{"id":"t_26fb0d551ec847daa7e30b4b280caf27","oldText":"The UserEditAtom contains two byte level offsets (again as 32 bit little endian numbers). At byte 12 is the offset to the PersistPtrIncrementalBlock associated with this UserEditAtom (each UserEditAtom has one and only one PersistPtrIncrementalBlock). At byte 8, there\u0027s the offset to the previous UserEditAtom. If this is 0, then you\u0027re at the first one.","tlText":"UserEditAtom 包含两个字节级别的偏移量（同样是 32 位小端数字）。第 12 个字节是与此 UserEditAtom 关联的 PersistPtrIncrementalBlock 的偏移量（每个 UserEditAtom 有一个且只有一个 PersistPtrIncrementalBlock）。在字节 8 处，是前一个 UserEditAtom 的偏移量。如果这是 0，那么你在第一个。","version":0},{"id":"t_d07219e4fab948fcbe90ca0cd97f6824","oldText":"Every time you do a non full save in PowerPoint, it tacks on another UserEditAtom and another PersistPtrIncrementalBlock. The CurrentUserAtom is updated to point to this new UserEditAtom, and the new UserEditAtom points back to the previous UserEditAtom. You then end up with a chain, starting from the CurrentUserAtom, linking back through all the UserEditAtoms, until you reach the first one from a full save.","tlText":"每次您在 PowerPoint 中执行非完整保存时，它都会附加另一个 UserEditAtom 和另一个 PersistPtrIncrementalBlock。 CurrentUserAtom 被更新为指向这个新的 UserEditAtom，而新的 UserEditAtom 又指向前一个 UserEditAtom。然后你会得到一个链，从 CurrentUserAtom 开始，通过所有 UserEditAtom 链接回来，直到你从完整保存中到达第一个。","version":0},{"id":"t_d35a30bb592946beaf4758de19621c42","oldText":"The PersistPtrIncrementalBlock contains byte offsets to all the Slides, Notes, Documents and MasterSlides in the file. The first PersistPtrIncrementalBlock will point to all the ones that were present the first time the file was saved. Subsequent PersistPtrIncrementalBlocks will contain pointers to all the ones that were changed in that edit. To find the offset to a given sheet in the latest version, then start with the most recent PersistPtrIncrementalBlock. If this knows about the sheet, use the offset it has. If it doesn\u0027t, then work back through older PersistPtrIncrementalBlocks until you find one which does, and use that.","tlText":"PersistPtrIncrementalBlock 包含文件中所有幻灯片、注释、文档和 MasterSlides 的字节偏移量。第一个 PersistPtrIncrementalBlock 将指向第一次保存文件时存在的所有块。随后的 PersistPtrIncrementalBlocks 将包含指向在该编辑中更改的所有内容的指针。要查找最新版本中给定工作表的偏移量，请从最新的 PersistPtrIncrementalBlock 开始。如果这知道工作表，请使用它的偏移量。如果没有，则通过旧的 PersistPtrIncrementalBlocks 重新工作，直到找到一个可以使用的方法，然后使用它。","version":0},{"id":"t_d4e219e26aa247abb310659a8ee5e872","oldText":"Each PersistPtrIncrementalBlock can contain a number of entries blocks. Each block holds information on a sequence of sheets. Each block starts with a 32 bit little endian integer. Once read into memory, the lower 20 bits contain the starting number for the sequence of sheets to be described. The higher 12 bits contain the count of the number of sheets described. Following that is one 32 bit little endian integer for each sheet in the sequence, the value being the offset to that sheet. If there is any data left after parsing a block, then it corresponds to the next block.","tlText":"每个 PersistPtrIncrementalBlock 可以包含多个条目块。每个块都包含有关一系列工作表的信息。每个块都以 32 位小端整数开头。读入内存后，低 20 位包含要描述的工作表序列的起始编号。高 12 位包含所描述的纸张数量的计数。接下来是序列中每个工作表的一个 32 位小端整数，该值是该工作表的偏移量。如果解析一个块后还有数据，则对应下一个块。","version":0},{"id":"t_3ff38520a1754b95b30d8182ecf8bda5","oldText":"There are quite a number of records that affect the styling of text, and a smaller number that are responsible for the styling of paragraphs.","tlText":"有相当多的记录会影响文本的样式，而较少的记录会影响段落的样式。","version":0},{"id":"t_30dbc21cfa13420db177b14056235a73","oldText":"By default, a given set of text will inherit paragraph and text stylings from the appropriate master sheet. If anything differs from the master sheet, then appropriate styling records will follow the text record.","tlText":"默认情况下，一组给定的文本将从相应的主工作表继承段落和文本样式。如果与主表有任何不同，则适当的样式记录将遵循文本记录。","version":0},{"id":"t_203170b52073494e9972d2c16fa0fbe2","oldText":"(We don\u0027t currently know enough about master sheet styling to write about it)","tlText":"（我们目前对母版样式的了解还不够，无法写出来）","version":0},{"id":"t_c0a6c3af69664b5f90a235d702846511","oldText":"Normally, powerpoint will have one text record (TextBytesAtom or TextCharsAtom) for every paragraph, with a preceding TextHeaderAtom to describe what sort of paragraph it is. If any of the stylings differ from the master\u0027s, then a StyleTextPropAtom will follow the text record. This contains the paragraph style information, and the styling information for each section of the text which has a different style. (More on StyleTextPropAtom later)","tlText":"通常，powerpoint 的每个段落都会有一个文本记录（TextBytesAtom 或 TextCharsAtom），前面有一个 TextHeaderAtom 来描述它是什么类型的段落。如果任何样式与主样式不同，则 StyleTextPropAtom 将跟随文本记录。这包含段落样式信息，以及具有不同样式的文本的每个部分的样式信息。 （稍后将详细介绍 StyleTextPropAtom）","version":0},{"id":"t_31f3c08c89f14158bcdb16d58dec9a5c","oldText":"For every font used, a FontEntityAtom must exist for that font. The FontEntityAtoms live inside a FontCollection record, and there\u0027s one of those inside Environment record inside the Document record. (More on Fonts to be discovered)","tlText":"对于使用的每种字体，该字体必须存在一个 FontEntityAtom。 FontEntityAtoms 存在于 FontCollection 记录中，其中一个位于 Document 记录中的 Environment 记录中。 （更多关于待发现的字体）","version":0},{"id":"t_467a2209c4874a5e84700683d015cc7c","oldText":"If the text or paragraph stylings for a given text record differ from those of the appropriate master, then there will be one of these records.","tlText":"如果给定文本记录的文本或段落样式与相应主记录的不同，则将存在这些记录之一。","version":0},{"id":"t_45cabd119e754ff3ab2f4680652d8575","oldText":"This record is made up of two lists of lists. Firstly, there\u0027s a list of paragraph stylings - each made up of the number of characters it applies two, followed by the matching styling elements. Following that is the equivalent for character stylings.","tlText":"此记录由两个列表列表组成。首先，有一个段落样式列表——每个都由它应用的两个字符组成，然后是匹配的样式元素。接下来是字符样式的等价物。","version":0},{"id":"t_d01a59e3c66b4fb0a9915ba3916a6d55","oldText":"Each styling list (in either list) starts with the number of characters it applies to, stored in a 2 byte little endian number. If it is a paragraph styling, it will be followed by a 2 byte number (of unknown use). After this is a four byte number, which is a mask indicating which stylings will follow. You then have an entry for each of the stylings indicated in the mask. Finally, you move onto the next set of stylings.","tlText":"每个样式列表（在任一列表中）都以其适用的字符数开始，存储在 2 字节的小端数中。如果是段落样式，后面会跟一个 2 字节的数字（用途不明）。之后是一个四字节的数字，它是一个掩码，指示将遵循哪些样式。然后，您可以为掩码中指示的每个样式创建一个条目。最后，您进入下一组样式。","version":0},{"id":"t_e0cde6ecd3bc4ff1819d69572d5d1349","oldText":"Each styling has a specific mask flag to indicate its presence. (The list may be found towards the top of org.apache.poi.hslf.record.StyleTextPropAtom.java, and is too long to sensibly include here). For each styling entry will occur in the order of its mask value (so one with mask 1 will come first, followed by the next highest mask value). Depending on the styling, it is either made up of a 2 byte or 4 byte numeric value. The meaning of the value will depend on the styling (eg for font.size, it is the font size in points).","tlText":"每个样式都有一个特定的掩码标志来指示它的存在。 （该列表可以在 org.apache.poi.hslf.record.StyleTextPropAtom.java 的顶部找到，并且由于太长而无法明智地包含在此处）。对于每个样式条目将按照其掩码值的顺序出现（因此具有掩码 1 的条目将首先出现，然后是下一个最高的掩码值）。根据样式，它由 2 字节或 4 字节数值组成。该值的含义将取决于样式（例如对于 font.size，它是以磅为单位的字体大小）。","version":0},{"id":"t_484188f99cd248ec8f625a4b26bd74cf","oldText":"Some stylings are actually mask stylings. For these, the value will be a 4 byte number. This is then processed as mask, to indicate a number of different sub-stylings. The styling for bold/italic/underline is one such example.","tlText":"一些样式实际上是面具样式。对于这些，该值将是一个 4 字节的数字。然后将其作为掩码处理，以指示许多不同的子样式。粗体/斜体/下划线的样式就是这样一个例子。","version":0},{"id":"t_b2243560ffa746758a7abe787bca7315","oldText":"PowerPoint stores information about the fonts used in FontEntityAtoms, which live inside Document.Environment.FontCollection. For every different font used, a FontEntityAtom must exist for that font. There is always at least one FontEntityAtom in Document.Environment.FontCollection, which describes the default font.","tlText":"PowerPoint 存储有关 FontEntityAtoms 中使用的字体的信息，这些信息位于 Document.Environment.FontCollection 中。对于使用的每种不同字体，该字体必须存在一个 FontEntityAtom。 Document.Environment.FontCollection 中始终至少有一个 FontEntityAtom，它描述了默认字体。","version":0},{"id":"t_c9b22e28f47e427e86a58035c486731e","oldText":"The instance field of the record header contains the zero based index of the font. Font index entries in StyleTextPropAtoms will refer to their required font via this index.","tlText":"记录头的实例字段包含从零开始的字体索引。 StyleTextPropAtoms 中的字体索引条目将通过该索引引用它们所需的字体。","version":0},{"id":"t_7f00f59d70c64ac08d7eb033011182c0","oldText":"The length of FontEntityAtoms is always 68 bytes. The first 64 bytes of it hold the typeface name of the font to be used. This is stored as a null-terminated string, and encoded as little endian unicode. (The length of the string must not exceed 32 characters including the null termination, so the typeface name cannot exceed 31 characters).","tlText":"FontEntityAtoms 的长度始终为 68 字节。它的前 64 个字节保存要使用的字体的字体名称。这存储为一个以空字符结尾的字符串，并编码为小端 unicode。 （字符串的长度不能超过 32 个字符，包括空终止符，所以字体名称不能超过 31 个字符）。","version":0},{"id":"t_5c76470179f741dd92c6de9a0ee7e816","oldText":"After the typeface name there are 4 bytes of bitmask flags. The details of these can be found in the Windows API, under the LOGFONT structure. The 65th byte is the output precision, which defines how closely the system chosen font must match the requested font, in terms of height, width, pitch etc. The 66th byte is the clipping precision, which defines how to clip characters that occur partly outside the clipping region. The 67th byte is the output quality, which defines how closely the system must match the logical font\u0027s attributes to those of the physical font used. The 68th (and final) byte is the pitch and family, which is used by the system when matching fonts.","tlText":"在字体名称之后有 4 个字节的位掩码标志。这些细节可以在 Windows API 的 LOGFONT 结构下找到。第 65 个字节是输出精度，它定义了系统选择的字体在高度、宽度、间距等方面与请求字体的匹配程度。第 66 个字节是剪切精度，它定义了如何剪切部分出现在外部的字符剪辑区域的方法。第 67 个字节是输出质量，它定义了系统必须将逻辑字体的属性与所使用的物理字体的属性匹配到何种程度。第 68 个（也是最后一个）字节是音高和系列，系统在匹配字体时使用。","version":0},{"id":"t_84a13167105e4342b5ee4921e657ab7f","oldText":"by Nick Burch, Yegor Kozlov","tlText":"尼克·伯奇、叶戈尔·科兹洛夫","version":0},{"id":"t_ea56d4b4b4c64f61b424be41b8b758e9","oldText":"1/2 byte container flag","tlText":"1/2 字节容器标志","version":0},{"id":"t_8d0a910f88894ffd93ac73dda7074a26","oldText":"1.5 byte option field","tlText":"1.5 字节选项字段","version":0},{"id":"t_1f0496b9efc84a959bd5980ab7c83651","oldText":"2 byte record type","tlText":"2字节记录类型","version":0},{"id":"t_87b2fd8656c14223beb95cf7421117c7","oldText":"4 byte record length","tlText":"4字节记录长度","version":0}]