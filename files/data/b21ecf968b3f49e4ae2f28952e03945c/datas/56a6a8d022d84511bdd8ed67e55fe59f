[{"id":"t_61e470ae598843f58ee753e12f57600a","oldText":"Apache POI - POIFS - Design Document","tlText":"Apache POI - POIFS - 设计文档","version":0},{"id":"t_6a146b5a76a34f5f87f3db65b8fcc261","oldText":"POIFS Design Document","tlText":"POIFS 设计文件","version":0},{"id":"t_f1449e95dbee4fc38f53173b6a98e32c","oldText":"Scope","tlText":"范围","version":0},{"id":"t_305226187f314b9faf756dabc35afe33","oldText":"Assumptions","tlText":"假设","version":0},{"id":"t_e79e953b7c4e43448d9f0d987886a0e3","oldText":"Design Considerations","tlText":"设计注意事项","version":0},{"id":"t_ba2f83d48f44436e935f51fc30118df9","oldText":"Design","tlText":"设计","version":0},{"id":"t_c68dc018e8814adb832730dffee70ad7","oldText":"Scenarios","tlText":"场景","version":0},{"id":"t_896beaa5dd71415cad2682dc9ea5e86c","oldText":"Block Classes and Interfaces","tlText":"块类和接口","version":0},{"id":"t_1d2d0afee34f418bb8c8fc294689f5ee","oldText":"Property Classes and Interfaces","tlText":"属性类和接口","version":0},{"id":"t_80c46d1982d64bceb5b6af32055e1344","oldText":"Filesystem Classes and Interfaces","tlText":"文件系统类和接口","version":0},{"id":"t_476aff8975774ae08d4fac6bd3392515","oldText":"Utility Classes and Interfaces","tlText":"实用程序类和接口","version":0},{"id":"t_dd824d97fa514783907aec6854d8e4e2","oldText":"Initialization","tlText":"初始化","version":0},{"id":"t_66f1c6bc869641a9a9b492d72dcc4f34","oldText":"Creating a Document","tlText":"创建文档","version":0},{"id":"t_3642bbcbb1d5480cba0c56ed1090d340","oldText":"Writing the Filesystem","tlText":"编写文件系统","version":0},{"id":"t_1c1d94aa8b6f4d2dab576e9c1573c1e9","oldText":"PropertyTable preWrite scenario diagram","tlText":"PropertyTable preWrite 场景图","version":0},{"id":"t_5db4d84ae0744c8a93f0fdde338c91f9","oldText":"RootProperty preWrite scenario diagram","tlText":"RootProperty preWrite 场景图","version":0},{"id":"t_f6254cc732e04c7ab24a178bfe51c4f7","oldText":"This document describes the design of the POIFS system. It is organized as follows:","tlText":"本文档描述了 POIFS 系统的设计。它的组织如下：","version":0},{"id":"t_662def6c70244862ad7f6c1d8d4346e9","oldText":"This document is written as part of an iterative process. As that process is not yet complete, neither is this document.","tlText":"本文档是作为迭代过程的一部分编写的。由于该过程尚未完成，因此本文档也未完成。","version":0},{"id":"t_db28703695824ad4a3da8a5e4ed8e7ad","oldText":"The design of POIFS is not dependent on the code written for the proof-of-concept prototype POIFS package.","tlText":"POIFS 的设计不依赖于为概念验证原型 POIFS 包编写的代码。","version":0},{"id":"t_813af7250ca44547b88531affea9dbf0","oldText":"As usual, the primary considerations in the design of the POIFS assumption involve the classic space-time tradeoff. In this case, the main consideration has to involve minimizing the memory footprint of POIFS. POIFS may be called upon to create relatively large documents, and in web application server, it may be called upon to create several documents simultaneously, and it will likely co-exist with other Serializer systems, competing with those other systems for space on the server.","tlText":"像往常一样，POIFS 假设设计中的主要考虑因素涉及经典的时空权衡。在这种情况下，主要考虑必须涉及最小化 POIFS 的内存占用。 POIFS 可能会被调用来创建比较大的文档，而在 Web 应用服务器中，它可能会被调用同时创建多个文档，并且它可能会与其他 Serializer 系统共存，与其他系统竞争服务器上的空间.","version":0},{"id":"t_e83a03cf51044865b141672117ba97c5","oldText":"We\u0027ve addressed the risk of being too slow through a proof-of-concept prototype. This prototype for POIFS involved reading an existing file, decomposing it into its constituent documents, composing a new POIFS from the constituent documents, and writing the POIFS file back to disk and verifying that the output file, while not necessarily a byte-for-byte image of the input file, could be read by the application that generated the input file. This prototype proved to be quite fast, reading, decomposing, and re-generating a large (300K) file in 2 to 2.5 seconds.","tlText":"我们已经通过概念验证原型解决了速度过慢的风险。 POIFS 的这个原型涉及读取现有文件，将其分解为其组成文档，从组成文档组成新的 POIFS，并将 POIFS 文件写回磁盘并验证输出文件，虽然不一定是逐字节输入文件的图像，可以由生成输入文件的应用程序读取。这个原型被证明是相当快的，在 2 到 2.5 秒内读取、分解和重新生成一个大 (300K) 文件。","version":0},{"id":"t_064eb524a28e45be9a08288b4d0acb7f","oldText":"While the POIFS format allows great flexibility in laying out the documents and the other internal data structures, the layout of the filesystem will be kept as simple as possible.","tlText":"虽然 POIFS 格式在布局文档和其他内部数据结构方面具有很大的灵活性，但文件系统的布局将尽可能简单。","version":0},{"id":"t_cfcf02180be34a8897419392fecc9744","oldText":"The design of the POIFS is broken down into two parts: discussion of the classes and interfaces, and discussion of how these classes and interfaces will be used to convert an appropriate Java InputStream (such as an XML stream) to a POIFS output stream containing an HSSF document.","tlText":"POIFS 的设计分为两部分：讨论类和接口，以及讨论如何使用这些类和接口将适当的 Java InputStream（例如 XML 流）转换为包含HSSF 文件。","version":0},{"id":"t_cb834601a2e54ad0b7d943a4c80c4edc","oldText":"Classes and Interfaces","tlText":"类和接口","version":0},{"id":"t_96006ee21dea45cdbaef85f1e9fca872","oldText":"The classes and interfaces used in the POIFS are broken down as follows:","tlText":"POIFS 中使用的类和接口细分如下：","version":0},{"id":"t_606e4b4a6c184cd4b32e81b5c3cc936e","oldText":"The block classes and interfaces are shownin the following class diagram.","tlText":"块类和接口如下图所示。","version":0},{"id":"t_e2b8bfcc6d6246b891690850f6039cdf","oldText":"The property classes and interfaces are shown in the following class diagram.","tlText":"下面的类图中显示了属性类和接口。","version":0},{"id":"t_602a835eb666482ab53bbe1391bfe41d","oldText":"The property classes and interfaces are shown in the following class diagram.","tlText":"下面的类图中显示了属性类和接口。","version":0},{"id":"t_e07ece6d65da421fbf8326416b2e5e13","oldText":"The utility classes and interfaces are shown in the following class diagram.","tlText":"实用程序类和接口显示在下面的类图中。","version":0},{"id":"t_025ef5265778488d9c8fe775e81a11c7","oldText":"This section describes the scenarios of how the POIFS classes and interfaces will be used to convert an appropriate XML stream to a POIFS output stream containing an HSSF document.","tlText":"本节描述如何使用 POIFS 类和接口将适当的 XML 流转换为包含 HSSF 文档的 POIFS 输出流的场景。","version":0},{"id":"t_59548d56fdb1434da1581461d0ba2593","oldText":"It is broken down as suggested by the following scenario diagram:","tlText":"它按照以下场景图的建议进行细分：","version":0},{"id":"t_2ef1b086d670413897adc9692e503e26","oldText":"Initialization of the POIFS system is shown in the following scenario diagram:","tlText":"POIFS系统的初始化如下图所示：","version":0},{"id":"t_a8c0d27d077f48a9b650780ae678767f","oldText":"Creating and adding a document to a POIFS system is shown in the following scenario diagram:","tlText":"在以下场景图中显示了创建文档并将其添加到 POIFS 系统：","version":0},{"id":"t_3ed5dce93efb4d5b80c0508dbab1173e","oldText":"Although typical deployment of the POIFS system will only entail adding a single Document (the workbook) to the Filesystem, there is nothing in the design to prevent multiple Documents from being added to the Filesystem. This flexibility can be employed to write summary information document(s) in addition to the workbook.","tlText":"虽然 POIFS 系统的典型部署只需要将单个文档（工作簿）添加到文件系统，但设计中没有任何内容可以防止将多个文档添加到文件系统。除了工作簿之外，这种灵活性还可用于编写摘要信息文档。","version":0},{"id":"t_1eb18cfc27e449359b2b067a37c9e6ee","oldText":"Writing the filesystem is shown in the following scenario diagram:","tlText":"编写文件系统如下图所示：","version":0},{"id":"t_0c943f07b6464669b802591bc5386a85","oldText":"Scope: A description of the limitations of this document.","tlText":"范围：对本文档限制的描述。","version":0},{"id":"t_35493498163c48a486cfdb9b02ebf45d","oldText":"Assumptions: The assumptions on which this design is based.","tlText":"假设：此设计所基于的假设。","version":0},{"id":"t_a01d012bdafa4726815203cc529cd443","oldText":"Design Considerations: The constraints and goals applied to the design.","tlText":"设计注意事项：应用于设计的约束和目标。","version":0},{"id":"t_ff70755690c24086afed011b50a174d3","oldText":"Design: The design of the POIFS system.","tlText":"设计：POIFS 系统的设计。","version":0},{"id":"t_abf6e2bfe77640389715b36a3cb70f74","oldText":"The HeaderBlock.","tlText":"页眉块。","version":0},{"id":"t_b429f2f414724ab3beda27fd24967f18","oldText":"Each Document, in the order in which it was added to the Filesystem.","tlText":"每个文档，按照它添加到文件系统的顺序。","version":0},{"id":"t_b4ba28ec78f846d38a5acc35f93305b2","oldText":"The PropertyTable.","tlText":"属性表。","version":0},{"id":"t_a824ebb2d5f94e9284b66ab899ca5494","oldText":"The BlockAllocationTable","tlText":"块分配表","version":0},{"id":"t_fec55bfe9591481092f96b1ede6d399f","oldText":"The XBAT blocks created by the HeaderBlock, if any.","tlText":"由 HeaderBlock 创建的 XBAT 块（如果有）。","version":0},{"id":"t_66a66b7b543947699633ff3c7e9713b8","oldText":"Package","tlText":"包裹","version":0},{"id":"t_278b88f1fac54aefbd553f82cf00bf54","oldText":"Contents","tlText":"内容","version":0},{"id":"t_90b5bf6630504cb59486728777ca0d33","oldText":"Class/Interface","tlText":"类/接口","version":0},{"id":"t_b8f2a6de00e44b62ac31829620ea989d","oldText":"Description","tlText":"描述","version":0},{"id":"t_09b1714efa5f4200bc5ddeef5a540635","oldText":"BATBlock","tlText":"BAT块","version":0},{"id":"t_98e40db807824db68451606901489004","oldText":"BigBlock","tlText":"大块","version":0},{"id":"t_9722c037dd0648bbb8e247a34bfa958b","oldText":"BlockWritable","tlText":"块可写","version":0},{"id":"t_f870e6b79e3b4fd98ed6a5895fc1a395","oldText":"DocumentBlock","tlText":"文档块","version":0},{"id":"t_d58023cf36cd4cb9a9a1a1e9667c8ff3","oldText":"HeaderBlock","tlText":"标题块","version":0},{"id":"t_3a7731502d8143de9f3eedab4f656d70","oldText":"PropertyBlock","tlText":"属性块","version":0},{"id":"t_2e6113909621480e8262ca003d86cc9b","oldText":"Class/Interface","tlText":"类/接口","version":0},{"id":"t_7b61fff0091a4c65ab1d4565ea1b2777","oldText":"Description","tlText":"描述","version":0},{"id":"t_7125da3eda5e477d8357d63fb620c1e3","oldText":"Directory","tlText":"目录","version":0},{"id":"t_5f249c2a0fea4f9aa21a3fdfbebdcbde","oldText":"DocumentProperty","tlText":"文档属性","version":0},{"id":"t_4888a5e88b4e4911b961c2e8dddfebeb","oldText":"File","tlText":"文件","version":0},{"id":"t_308d1edcf9ad4b67a27d3e39d81a8677","oldText":"Property","tlText":"财产","version":0},{"id":"t_ad2dd3a156d44f19a0fc8df2e1c61fa1","oldText":"PropertyBlock","tlText":"属性块","version":0},{"id":"t_ac3c6441c1f14895aa6f402f8429129f","oldText":"PropertyTable","tlText":"属性表","version":0},{"id":"t_97e59cf7cd7f4d09bae95009758c26d3","oldText":"RootProperty","tlText":"根属性","version":0},{"id":"t_151eed6a2c584989817cef497c16d1cc","oldText":"Class/Interface","tlText":"类/接口","version":0},{"id":"t_0a797cd686a64817ae6892ba1947bc26","oldText":"Description","tlText":"描述","version":0},{"id":"t_d253ac9534b348da9b5d5785eb192a02","oldText":"Filesystem","tlText":"文件系统","version":0},{"id":"t_99ae1d7b44fa4603bcd69029620919ab","oldText":"BATBlock","tlText":"BAT块","version":0},{"id":"t_0d9fd656d6074a24b05880c5b2195aa9","oldText":"BATManaged","tlText":"BAT托管","version":0},{"id":"t_a1613f8bb6d64bfe87eb2dd5998079d5","oldText":"BlockAllocationTable","tlText":"块分配表","version":0},{"id":"t_1a96a41409d1442ead3e8e1ba9ee48dd","oldText":"BlockWritable","tlText":"块可写","version":0},{"id":"t_c0bca8f72d4747a2a17d2b030086dbaa","oldText":"Document","tlText":"文档","version":0},{"id":"t_5f702157a122447f9d4d1de3e401570a","oldText":"DocumentBlock","tlText":"文档块","version":0},{"id":"t_a7a862012ced46dfbd9ecdd6cd93b244","oldText":"DocumentProperty","tlText":"文档属性","version":0},{"id":"t_bfe9bad5d39e44ca8208e0a1398b5c28","oldText":"HeaderBlock","tlText":"标题块","version":0},{"id":"t_2dfdafd7289640c5a32faf228df518a2","oldText":"PropertyTable","tlText":"属性表","version":0},{"id":"t_3d85f12f5d404ca2b927038ae07272ca","oldText":"Class/Interface","tlText":"类/接口","version":0},{"id":"t_382b994594c04abc999bc5ae7da20f09","oldText":"Description","tlText":"描述","version":0},{"id":"t_a897f739c48841e78cee9699b90a7eb7","oldText":"BitField","tlText":"位域","version":0},{"id":"t_fd7fbb1aa7a244418b404c78792d374f","oldText":"ByteField","tlText":"字节字段","version":0},{"id":"t_37b2af8766fe4330a82d02202e7b7771","oldText":"FixedField","tlText":"固定场","version":0},{"id":"t_f516e33afad347968d1a7ec173d303c1","oldText":"HexDump","tlText":"十六进制转储","version":0},{"id":"t_018d2d22c9fa48149e0dee0e69e2477c","oldText":"IntegerField","tlText":"整数字段","version":0},{"id":"t_41aa91b06e6d4f379be7a88f277cdb9a","oldText":"IntList","tlText":"整数列表","version":0},{"id":"t_2a44f07c4afe4215a5e36fecbe923f73","oldText":"LittleEndian","tlText":"小端","version":0},{"id":"t_a3ec843547904d4da8a6e853fa5ede7b","oldText":"LittleEndianConsts","tlText":"LittleEndian 常量","version":0},{"id":"t_9d4bccee55884de68d9bea14d40d068d","oldText":"LongField","tlText":"长场","version":0},{"id":"t_d3db46ff8c1c4fbabd84fa0684aab070","oldText":"ShortField","tlText":"短场","version":0},{"id":"t_263e9b1db4c747b49c087d20a3f6fb06","oldText":"ShortList","tlText":"入围名单","version":0},{"id":"t_269031193910496a8d2f07a27b43cd40","oldText":"StringUtil","tlText":"字符串工具","version":0},{"id":"t_a673b01cb5214fe8af0d9fcd042c3e53","oldText":"Step","tlText":"步","version":0},{"id":"t_30e71c3fc7fe4a44af156331743ace88","oldText":"Description","tlText":"描述","version":0},{"id":"t_2bd1fa5fa566428e95a2ce87758cab7f","oldText":"1","tlText":"1","version":0},{"id":"t_553707282ada4063baf1fa4b6ea89157","oldText":"2","tlText":"2","version":0},{"id":"t_e0bb58ae6baa4194aa880d28ae2c9833","oldText":"3","tlText":"3","version":0},{"id":"t_9b8c49c46b7942e0aa769268ff8454eb","oldText":"Step","tlText":"步","version":0},{"id":"t_7dce8278fde14fe2b62a0f1e827899a9","oldText":"Description","tlText":"描述","version":0},{"id":"t_228faa89f0dd45889cdbbfddb2ef07de","oldText":"1","tlText":"1","version":0},{"id":"t_abab1c7681f741bf8348822b6b8552f4","oldText":"2","tlText":"2","version":0},{"id":"t_cea55b10e47349bf88b466b8fc3abef8","oldText":"3","tlText":"3","version":0},{"id":"t_b915b7669f0943cc8c46a683bdb9d7d4","oldText":"Step","tlText":"步","version":0},{"id":"t_916b30c6a6404be7abaf4662cd1a0f8c","oldText":"Description","tlText":"描述","version":0},{"id":"t_a6df170ae19946fc9697d6dda084c2a2","oldText":"1","tlText":"1","version":0},{"id":"t_63609e39cd044d04819b77596ce1faa2","oldText":"2","tlText":"2","version":0},{"id":"t_c935373697134ac3aa2b56dccaf0ee09","oldText":"3","tlText":"3","version":0},{"id":"t_43c944bbfb704c3c8c5e656e99de1a7b","oldText":"4","tlText":"4","version":0},{"id":"t_ef3b2fa322e44676b1c10c3ea2682ff4","oldText":"5","tlText":"5","version":0},{"id":"t_e8cedfbf58e54a669c05553340518167","oldText":"6","tlText":"6","version":0},{"id":"t_fec927f60c6547f3acacfa3e6d46db07","oldText":"7","tlText":"7","version":0},{"id":"t_36d7df4f21c74e679e81ae1bc78e1bb4","oldText":"Step","tlText":"步","version":0},{"id":"t_12d5e9ee94ec465194f752d3bf490d89","oldText":"Description","tlText":"描述","version":0},{"id":"t_b74fb58299c5439cb38d64efd4f11b01","oldText":"1","tlText":"1","version":0},{"id":"t_fbed144e98b04c83bc554a3a7ed516a9","oldText":"2","tlText":"2","version":0},{"id":"t_5bfa2f01098d40679148cb2eb1a28791","oldText":"3","tlText":"3","version":0},{"id":"t_5491550cd26644e1be738799347d0b75","oldText":"4","tlText":"4","version":0},{"id":"t_b7b16926763d40f5acbb3a0fbddcd9dc","oldText":"5","tlText":"5","version":0},{"id":"t_5cdb20db8cda4304ac1f6dfa7f003d17","oldText":"6","tlText":"6","version":0},{"id":"t_e05f6bc70100447fa5b5ce8318c8cd2b","oldText":"7","tlText":"7","version":0},{"id":"t_3e31714b31364ae39a9e5a03187d68a1","oldText":"8","tlText":"8","version":0},{"id":"t_8e8586055a5743e1a8d1175e96f85a27","oldText":"9","tlText":"9","version":0},{"id":"t_3dc5dda630ff46d99bff9686a300c448","oldText":"10","tlText":"10","version":0},{"id":"t_e66824b09b7441b58c6dbed25559f78a","oldText":"Step","tlText":"步","version":0},{"id":"t_b505fb926c4844f9ad20a206477ce597","oldText":"Description","tlText":"描述","version":0},{"id":"t_09467a03391e40468dc59889e46d78f9","oldText":"1","tlText":"1","version":0},{"id":"t_6995c4b41d9d4420a8259de0fdc886c5","oldText":"2","tlText":"2","version":0},{"id":"t_fcfe14b3e1ff482f8faf2991c4ccf2ab","oldText":"3","tlText":"3","version":0},{"id":"t_cb16179a14ec4385afc51104998d0a7f","oldText":"4","tlText":"4","version":0},{"id":"t_37091f3947664803852d8508704cfb4d","oldText":"5","tlText":"5","version":0},{"id":"t_367caef376bd4b63b9b9524de6fbe590","oldText":"Step","tlText":"步","version":0},{"id":"t_28fa4e154b524869a066f2b44cbc8c95","oldText":"Description","tlText":"描述","version":0},{"id":"t_addac81a278946609d2d4b9b0245e7af","oldText":"1","tlText":"1","version":0},{"id":"t_1e551f3e061e4e90b2c1d0f3d8fd10e3","oldText":"2","tlText":"2","version":0},{"id":"t_3a3a954a9b0d4a278f9d971ec5c54a47","oldText":"3","tlText":"3","version":0},{"id":"t_588dcf5eebf249d3bc9349070399a803","oldText":"net.sourceforge.poi.poifs.storage","tlText":"net.sourceforge.poi.poifs.storage","version":0},{"id":"t_3c253cf40e7947c48c796e88d01b08ba","oldText":"Block classes and interfaces","tlText":"块类和接口","version":0},{"id":"t_21ea6c77c0ee4a12b5d0c1ae89bedd51","oldText":"net.sourceforge.poi.poifs.property","tlText":"net.sourceforge.poi.poifs.property","version":0},{"id":"t_5bae4afd38df4ec6989560cf34f8121b","oldText":"Property classes and interfaces","tlText":"属性类和接口","version":0},{"id":"t_869b4fb02e894e4b9f34a35815af7007","oldText":"net.sourceforge.poi.poifs.filesystem","tlText":"net.sourceforge.poi.poifs.filesystem","version":0},{"id":"t_608e8a39febc45ed8dff5b0e8b77b739","oldText":"Filesystem classes and interfaces","tlText":"文件系统类和接口","version":0},{"id":"t_dfcb5949181e4167bde636abfbc8c8e1","oldText":"net.sourceforge.poi.util","tlText":"net.sourceforge.poi.util","version":0},{"id":"t_0660f2b6e4c64f6facef217e41d89dca","oldText":"Utility classes and interfaces","tlText":"实用程序类和接口","version":0},{"id":"t_d7093ebba0344549bd957b1aed9ea7d8","oldText":"The BATBlock class represents a single big block containing 128 BAT entries. Its _fields array is used to read and write the BAT entries into the _data array. Its createBATBlocks method is used to create an array of BATBlock instances from an array of int BAT entries. Its calculateStorageRequirements method calculates the number of BAT blocks necessary to hold the specified number of BAT entries.","tlText":"BATBlock 类代表一个包含 128 个 BAT 条目的大块。它的 _fields 数组用于读取 BAT 条目并将其写入 _data 数组。它的 createBATBlocks 方法用于从 int BAT 条目数组创建 BATBlock 实例数组。它的 calculateStorageRequirements 方法计算保存指定数量的 BAT 条目所需的 BAT 块数。","version":0},{"id":"t_86d32ec880404d54bd3064d38d8064b8","oldText":"The BigBlock class is an abstract class representing the common big block of 512 bytes. It implements BlockWritable, trivially delegating the writeBlocks method of BlockWritable to its own abstract writeData method.","tlText":"BigBlock 类是一个抽象类，代表 512 字节的公共大块。它实现了 BlockWritable，将 BlockWritable 的 writeBlocks 方法委派给它自己的抽象 writeData 方法。","version":0},{"id":"t_2fe1f87df8ea4c7799bf666affb3c872","oldText":"The BlockWritable interface defines a single method, writeBlocks, that is used to write an implementation\u0027s block data to an OutputStream.","tlText":"BlockWritable 接口定义了一个方法 writeBlocks，用于将实现的块数据写入 OutputStream。","version":0},{"id":"t_d91d0c96df7942b8a014cb40bb2459cb","oldText":"The DocumentBlock class is used by a Document to holds its raw data. It also retains the number of bytes read, as this is used by the Document class to determine the total size of the data, and is also used internally to determine whether the block was filled by the InputStream or not. The DocumentBlock constructor is passed an InputStream from which to fill its _data array. The size method returns the number of bytes read (_bytes_read) when the instance was constructed. The partiallyRead method returns true if the _data array was not completely filled, which may be interpreted by the Document as having reached the end of file point. Typical use of the DocumentBlock class is like this: while (true) { DocumentBlock block \u003d new DocumentBlock(stream); blocks.add(block); size +\u003d block.size(); if (block.partiallyRead()) { break; } }","tlText":"DocumentBlock 类被 Document 用来保存其原始数据。它还保留读取的字节数，因为 Document 类使用它来确定数据的总大小，并且在内部也用于确定块是否由 InputStream 填充。 DocumentBlock 构造函数被传递一个 InputStream 来填充它的 _data 数组。 size 方法返回构造实例时读取的字节数（_bytes_read）。如果 _data 数组未完全填充，partialRead 方法返回 true，这可能被 Document 解释为已到达文件末尾点。 DocumentBlock 类的典型用法是这样的： while (true) { DocumentBlock block \u003d new DocumentBlock(stream);块。添加（块）；大小 +\u003d 块大小（）； if (block.partiallyRead()) { break; } }","version":0},{"id":"t_89f726e691aa4475b9e20171dad7e027","oldText":"The HeaderBlock class is used to contain the data found in a POIFS header. Its IntegerField members are used to read and write the appropriate entries into the _data array. Its setBATBlocks , setPropertyStart , and setXBATStart methods are used to set the appropriate fields in the _data array. The calculateXBATStorageRequirements method is used to determine how many XBAT blocks are necessary to accommodate the specified number of BAT blocks.","tlText":"HeaderBlock 类用于包含在 POIFS 标头中找到的数据。它的 IntegerField 成员用于在 _data 数组中读取和写入适当的条目。它的 setBATBlocks 、 setPropertyStart 和 setXBATStart 方法用于设置 _data 数组中的相应字段。 calculateXBATStorageRequirements 方法用于确定需要多少 XBAT 块才能容纳指定数量的 BAT 块。","version":0},{"id":"t_1d0a8ccc8b884d77924240624be6d6b9","oldText":"The PropertyBlock class is used to contain Property instances for the PropertyTable class. It contains an array, _properties of 4 Property instances, which together comprise the 512 bytes of a BigBlock. The createPropertyBlockArray method is used to convert a List of Property instances into an array of PropertyBlock instances. The number of Property instances is rounded up to a multiple of 4 by creating empty anonymous inner class extensions of Property.","tlText":"PropertyBlock 类用于包含 PropertyTable 类的属性实例。它包含一个数组，4 个 Property 实例的 _properties，它们共同构成了 BigBlock 的 512 个字节。 createPropertyBlockArray 方法用于将 Property 实例列表转换为 PropertyBlock 实例数组。通过创建 Property 的空匿名内部类扩展，Property 实例的数量向上舍入为 4 的倍数。","version":0},{"id":"t_d70d900834d04aeb8d13ba25bae9fa2f","oldText":"The Directory interface is implemented by the RootProperty class. It is not strictly necessary for the initial POIFS implementation, but when the POIFS supports directory elements, this interface will be more widely implemented, and so is included in the design at this point to ease the eventual support of directory elements. Its methods are a getter/setter pair, getChildren , returning an Iterator of Property instances; and addChild , which will allow the caller to add another Property instance to the Directory\u0027s children.","tlText":"Directory 接口由 RootProperty 类实现。最初的 POIFS 实现并不是绝对必要的，但是当 POIFS 支持目录元素时，该接口将得到更广泛的实现，因此此时将其包含在设计中，以简化对目录元素的最终支持。它的方法是一个 getter/setter 对 getChildren ，返回一个 Property 实例的 Iterator；和 addChild ，这将允许调用者将另一个 Property 实例添加到 Directory 的子级。","version":0},{"id":"t_4f838e944abd457a939e6e4ea5ea6353","oldText":"The DocumentProperty class is a trivial extension of Property and is used by Document to keep track of its associated entry in the PropertyTable. Its constructor takes a name and the document size, on the assumption that the Document will not create a DocumentProperty until after it has created the storage for the document data and therefore knows how much data there is.","tlText":"DocumentProperty 类是 Property 的一个简单扩展，Document 使用它来跟踪其在 PropertyTable 中的关联条目。它的构造函数采用名称和文档大小，假设 Document 在为文档数据创建存储并因此知道有多少数据之前不会创建 DocumentProperty。","version":0},{"id":"t_a036a58280a240d0bc5cf53266f6b1d5","oldText":"The File interface specifies the behavior of reading and writing the next and previous child fields of a Property.","tlText":"File 接口指定读取和写入属性的下一个和上一个子字段的行为。","version":0},{"id":"t_3211e6d2c7074ee790f3b25634a9ffba","oldText":"The Property class is an abstract class that defines the basic data structure of an element of the Property Table. Its ByteField, ShortField, and IntegerField members are used to read and write data into the appropriate locations in the _raw_data array. The _index member is used to hold a Propery instance\u0027s index in the List of Property instances maintained by PropertyTable, which is used to populate the child property of parent Directory properties and the next property and previous property of sibling File properties. The _name , _next_file , and _previous_file members are used to help fill the appropriate fields of the _raw_data array. Setters are provided for some of the fields (name, property type, node color, child property, size, index, start block), as well as a few getters (index, child property). The preWrite method is abstract and is used by the owning PropertyTable to iterate through its Property instances and prepare each for writing. The shouldUseSmallBlocks method returns true if the Property\u0027s size is sufficiently small - how small is none of the caller\u0027s business.","tlText":"Property 类是一个抽象类，它定义了 Property Table 元素的基本数据结构。它的 ByteField、ShortField 和 IntegerField 成员用于读取和写入数据到 _raw_data 数组中的适当位置。 _index成员用于保存Propery实例在PropertyTable维护的Property实例列表中的索引，用于填充父目录属性的子属性以及兄弟文件属性的下一个属性和上一个属性。 _name 、 _next_file 和 _previous_file 成员用于帮助填充 _raw_data 数组的相应字段。为某些字段（名称、属性类型、节点颜色、子属性、大小、索引、开始块）以及一些 getter（索引、子属性）提供了设置器。 preWrite 方法是抽象的，由拥有的 PropertyTable 使用来遍历其 Property 实例并准备每个实例以进行写入。如果属性的大小足够小，shouldUseSmallBlocks 方法将返回 true - 调用者的业务有多小无关紧要。","version":0},{"id":"t_361b299897c443a788b4a37a006cf122","oldText":"See the description in PropertyBlock.","tlText":"请参阅 PropertyBlock 中的说明。","version":0},{"id":"t_8e24fbd3511c405580821dc160098cb5","oldText":"The PropertyTable class holds all of the DocumentProperty instances and the RootProperty instance for a Filesystem instance. It maintains a List of its Property instances ( _properties ), and when prepared to write its data by a call to preWrite , it gets and holds an array of PropertyBlock instances ( _blocks) . It also maintains its start block in its _start_block member. It has a method, getRoot , to get the RootProperty, returning it as an implementation of Directory, and a method to add a Property, addProperty , and a method to get its start block, getStartBlock .","tlText":"PropertyTable 类包含所有 DocumentProperty 实例和 Filesystem 实例的 RootProperty 实例。它维护其 Property 实例 (_properties) 的列表，当准备通过调用 preWrite 写入其数据时，它获取并保存 PropertyBlock 实例 (_blocks) 的数组。它还在其 _start_block 成员中维护其起始块。它有一个方法 getRoot 来获取 RootProperty，将其作为 Directory 的实现返回，还有一个添加属性的方法 addProperty 和一个获取其起始块的方法 getStartBlock 。","version":0},{"id":"t_fda2601ad5a2479cb677b1688cd42148","oldText":"The RootProperty class acts as the Directory for all of the DocumentProperty instance. As such, it is more of a pure directory entry than a proper root entry in the Property Table, but the initial POIFS implementation does not warrant the additional complexity of a full-blown root entry, and so it is not modeled in this design. It maintains a List of its children, _children , in order to perform its directory-oriented duties.","tlText":"RootProperty 类充当所有 DocumentProperty 实例的目录。因此，它更像是一个纯粹的目录条目，而不是属性表中的正确根条目，但最初的 POIFS 实现并不保证完整的根条目的额外复杂性，因此在此设计中没有对其进行建模。它维护其子项的列表 _children ，以执行其面向目录的职责。","version":0},{"id":"t_9bd8e924692a42f6bc9e6511c32c987a","oldText":"The Filesystem class is the top-level class that manages the creation of a POIFS document. It maintains a PropertyTable instance in its _property_table member, a HeaderBlock instance in its _header_block member, and a List of its Document instances in its _documents member. It provides methods for a client to create a document ( createDocument ), and a method to write the Filesystem to an OutputStream ( writeFilesystem ).","tlText":"Filesystem 类是管理 POIFS 文档创建的顶级类。它在其 _property_table 成员中维护一个 PropertyTable 实例，在其 _header_block 成员中维护一个 HeaderBlock 实例，并在其 _documents 成员中维护其 Document 实例的列表。它为客户端提供创建文档的方法（createDocument），以及将文件系统写入输出流（writeFilesystem）的方法。","version":0},{"id":"t_ca47a4b33cf54f889ec2dcdd2a9eae2a","oldText":"See the description in BATBlock","tlText":"见BATBlock中的描述","version":0},{"id":"t_5bd3ac60689a42aebd84f99bc89d3f70","oldText":"The BATManaged interface defines common behavior for objects whose location in the written file is managed by the Block Allocation Table. It defines methods to get a count of the implementation\u0027s BigBlock instances ( countBlocks ), and to set an implementation\u0027s start block ( setStartBlock ).","tlText":"BATManaged 接口定义了对象在写入文件中的位置由块分配表管理的常见行为。它定义了获取实现的 BigBlock 实例计数 (countBlocks) 和设置实现的开始块 (setStartBlock) 的方法。","version":0},{"id":"t_34df9c7a6cb14d109e6673e8f78bd57e","oldText":"The BlockAllocationTable is an implementation of the POIFS Block Allocation Table. It is only created when the Filesystem is about to be written to an OutputStream. It contains an IntList of block numbers for all of the BATManaged implementations owned by the Filesystem, _entries , which is filled by calls to allocateSpace . It fills its array, _blocks , of BATBlock instances when its createBATBlocks method is called. This method has to take into account its own storage requirements, as well as those of the XBAT blocks, and so calls BATBlock.calculateStorageRequirements and HeaderBlock.calculateXBATStorageRequirements repeatedly until the counts returned by those methods stabilize. The countBlocks method returns the number of BATBlock instances created by the preceding call to createBlocks.","tlText":"BlockAllocationTable 是 POIFS 块分配表的实现。它仅在文件系统即将写入 OutputStream 时创建。它包含由文件系统 _entries 拥有的所有 BATManaged 实现的块编号的 IntList，它由对 allocateSpace 的调用填充。当调用它的 createBATBlocks 方法时，它会填充 _blocks 的 BATBlock 实例数组。此方法必须考虑其自身的存储需求以及 XBAT 块的存储需求，因此会重复调用 BATBlock.calculateStorageRequirements 和 HeaderBlock.calculateXBATStorageRequirements，直到这些方法返回的计数稳定。 countBlocks 方法返回由前面调用 createBlocks 创建的 BATBlock 实例的数量。","version":0},{"id":"t_5fde6d8a4aa744a08a3658a04e513a6f","oldText":"See the description in BlockWritable","tlText":"参见 BlockWritable 中的描述","version":0},{"id":"t_af3e7efab94843f186029227bbe28cb2","oldText":"The Document class is used to contain a document, such as an HSSF workbook. It has its own DocumentProperty ( _property ) and stores its data in a collection of DocumentBlock instances ( _blocks ). It has a method, getDocumentProperty , to get its DocumentProperty.","tlText":"Document 类用于包含文档，例如 HSSF 工作簿。它有自己的 DocumentProperty (_property)，并将其数据存储在 DocumentBlock 实例 (_blocks) 的集合中。它有一个方法 getDocumentProperty 来获取它的 DocumentProperty。","version":0},{"id":"t_5d4d8c97338c4f2eb52cca9ae6079fef","oldText":"See the description in DocumentBlock","tlText":"请参阅 DocumentBlock 中的说明","version":0},{"id":"t_c885238163554e38b2de55e8a374b90d","oldText":"See the description in DocumentProperty","tlText":"请参阅 DocumentProperty 中的说明","version":0},{"id":"t_1d838a6c86d94e3c869f0840b62e43c3","oldText":"See the description in HeaderBlock","tlText":"见 HeaderBlock 中的描述","version":0},{"id":"t_3d81c9d5e6704510a04a3315a8a5ef8b","oldText":"See the description in PropertyTable","tlText":"参见 PropertyTable 中的描述","version":0},{"id":"t_e807d9e865f947e9b668830c4d3ecb6f","oldText":"The BitField class is used primarily by HSSF code to manage bit-mapped fields of HSSF records. It is not likely to be used in the POIFS code itself and is only included here for the sake of complete documentation of the POI utility classes.","tlText":"BitField 类主要由 HSSF 代码用于管理 HSSF 记录的位映射字段。它不太可能在 POIFS 代码本身中使用，并且只是为了 POI 实用程序类的完整文档而包含在此处。","version":0},{"id":"t_7396f883a51747f88d1dd328724a34ba","oldText":"The ByteField class is an implementation of FixedField for the purpose of managing reading and writing to a byte-wide field in an array of bytes.","tlText":"ByteField 类是 FixedField 的实现，用于管理对字节数组中字节范围字段的读取和写入。","version":0},{"id":"t_652b2ffec37d46e780b247bf95b56fcd","oldText":"The FixedField interface defines a set of methods for reading a field from an array of bytes or from an InputStream, and for writing a field to an array of bytes. Implementations typically require an offset in their constructors that, for the purposes of reading and writing to an array of bytes, makes sure that the correct bytes in the array are read or written.","tlText":"FixedField 接口定义了一组方法，用于从字节数组或 InputStream 中读取字段，以及将字段写入字节数组。实现通常在其构造函数中需要一个偏移量，为了读取和写入字节数组，确保读取或写入数组中的正确字节。","version":0},{"id":"t_7c3f2ee5bf8a4cc283198a82cf2aaf89","oldText":"The HexDump class is a debugging class that can be used to dump an array of bytes to an OutputStream. The static method dump takes an array of bytes, a long offset that is used to label the output, an open OutputStream, and an int index that specifies the starting index within the array of bytes. The data is displayed 16 bytes per line, with each byte displayed in hexadecimal format and again in printable form, if possible (a byte is considered printable if its value is in the range of 32 ... 126). Here is an example of a small array of bytes with an offset of 0x110: 00000110 C8 00 00 00 FF 7F 90 01 00 00 00 00 00 00 05 01 ................ 00000120 41 00 72 00 69 00 61 00 6C 00 A.r.i.a.l.","tlText":"HexDump 类是一个调试类，可用于将字节数组转储到 OutputStream。静态方法 dump 需要一个字节数组、一个用于标记输出的长偏移量、一个打开的 OutputStream 和一个 int 索引，该索引指定字节数组中的起始索引。数据以每行 16 个字节显示，每个字节以十六进制格式显示，如果可能，再以可打印形式显示（如果一个字节的值在 32 ... 126 范围内，则认为它是可打印的）。下面是一个偏移量为 0x110 的小字节数组的示例： 00000110 C8 00 00 00 FF 7F 90 01 00 00 00 00 00 00 05 01 ...... 00000120 41 00 72 00 69 00 61 00 6C 00 宋体","version":0},{"id":"t_1dedc56376ce478ab342cc945f97e4d4","oldText":"The IntegerField class is an implementation of FixedField for the purpose of managing reading and writing to an integer-wide field in an array of bytes.","tlText":"IntegerField 类是 FixedField 的实现，用于管理对字节数组中整数范围字段的读取和写入。","version":0},{"id":"t_01b6245a9a42498e828b99599eb3f1d6","oldText":"The IntList class is a work-around for functionality missing in Java (see http://developer.java.sun.com/developer/bugParade/bugs/4487555.html for details); it is a simple growable array of ints that gets around the requirement of wrapping and unwrapping ints in Integer instances in order to use the java.util.List interface. IntList mimics the functionality of the java.util.List interface as much as possible.","tlText":"IntList 类是 Java 中缺少的功能的解决方法（有关详细信息，请参见 http://developer.java.sun.com/developer/bugParade/bugs/4487555.html）；它是一个简单的可增长整数数组，它绕过了在 Integer 实例中包装和展开整数的要求，以便使用 java.util.List 接口。 IntList 尽可能地模仿 java.util.List 接口的功能。","version":0},{"id":"t_f53d3351397a4cbb9c98b188e11ce45b","oldText":"The LittleEndian class provides a set of static methods for reading and writing shorts, ints, longs, and doubles in and out of byte arrays, and out of InputStreams, preserving the Intel byte ordering and encoding of these values.","tlText":"LittleEndian 类提供了一组静态方法，用于在字节数组和 InputStream 之外读取和写入 short、int、long 和 double，保留这些值的 Intel 字节顺序和编码。","version":0},{"id":"t_e02d3cab6c7e4226beea4fc6edb5a83d","oldText":"The LittleEndianConsts interface defines the width of a short, int, long, and double as stored by Intel processors.","tlText":"LittleEndianConsts 接口定义了 Intel 处理器存储的 short、int、long 和 double 的宽度。","version":0},{"id":"t_65dfa608708b498ab6e3e0f3670f0e33","oldText":"The LongField class is an implementation of FixedField for the purpose of managing reading and writing to a long-wide field in an array of bytes.","tlText":"LongField 类是 FixedField 的实现，用于管理对字节数组中长宽字段的读取和写入。","version":0},{"id":"t_cc9c01861dc147c09cfffc7acc359a64","oldText":"The ShortField class is an implementation of FixedField for the purpose of managing reading and writing to a short-wide field in an array of bytes.","tlText":"ShortField 类是 FixedField 的实现，用于管理对字节数组中的短宽字段的读取和写入。","version":0},{"id":"t_d739f2141c0e471d947d12fe854f0f4e","oldText":"The ShortList class is a work-around for functionality missing in Java (see http://developer.java.sun.com/developer/bugParade/bugs/4487555.html for details); it is a simple growable array of shorts that gets around the requirement of wrapping and unwrapping shorts in Short instances in order to use the java.util.List interface. ShortList mimics the functionality of the java.util.List interface as much as possible.","tlText":"ShortList 类是 Java 中缺少的功能的解决方法（有关详细信息，请参见 http://developer.java.sun.com/developer/bugParade/bugs/4487555.html）；它是一个简单的可增长的短裤数组，它绕过了在 Short 实例中包装和展开短裤的要求，以便使用 java.util.List 接口。 ShortList 尽可能地模仿 java.util.List 接口的功能。","version":0},{"id":"t_3ad970d878384e1e9bc2bf77eaf2affd","oldText":"The StringUtil class manages the processing of Unicode strings.","tlText":"StringUtil 类管理 Unicode 字符串的处理。","version":0},{"id":"t_e31a967d616348daabd9c9d2eb444224","oldText":"The Filesystem is created by the client application.","tlText":"文件系统由客户端应用程序创建。","version":0},{"id":"t_5b78b5abdaf44c0c90e31b6efb48c9ee","oldText":"The client application tells the Filesystem to create a document, providing an InputStream and the name of the document. This may be repeated several times.","tlText":"客户端应用程序告诉文件系统创建一个文档，提供一个 InputStream 和文档的名称。这可以重复几次。","version":0},{"id":"t_fd0daeb269c0473f9198f6226ce65a82","oldText":"The client application asks the Filesystem to write its data to an OutputStream.","tlText":"客户端应用程序要求文件系统将其数据写入输出流。","version":0},{"id":"t_657a9ebbe7cb4b1f99a6dcc48094cd1b","oldText":"The Filesystem object, which is created for each request to convert an appropriate XML stream to a POIFS output stream containing an HSSF document, creates its PropertyTable.","tlText":"Filesystem 对象是为每个请求创建的，用于将适当的 XML 流转换为包含 HSSF 文档的 POIFS 输出流，并创建其 PropertyTable。","version":0},{"id":"t_a483c191719a4ba3889ef8b8193885d5","oldText":"The PropertyTable creates its RootProperty instance, making the RootProperty the first Property in its List of Property instances.","tlText":"PropertyTable 创建其 RootProperty 实例，使 RootProperty 成为其 Property 实例列表中的第一个 Property。","version":0},{"id":"t_2eb168ade66b493f9d09bbc46ceb651f","oldText":"The Filesystem creates its HeaderBlock instance. It should be noted that the decision to create the HeaderBlock at Filesystem initialization is arbitrary; creation of the HeaderBlock could easily and harmlessly be postponed to the appropriate moment in writing the filesystem.","tlText":"文件系统创建它的 HeaderBlock 实例。应该注意的是，在文件系统初始化时创建 HeaderBlock 的决定是任意的； HeaderBlock 的创建可以轻松且无害地推迟到写入文件系统的适当时刻。","version":0},{"id":"t_82a513d565e7462cb553dd48adb0723d","oldText":"The Filesystem instance creates a new Document instance. It will store the newly created Document in a List of BATManaged instances.","tlText":"Filesystem 实例创建一个新的 Document 实例。它将新创建的文档存储在 BATManaged 实例列表中。","version":0},{"id":"t_a49e1ead88e4489da84dc706f2c030e9","oldText":"The Document reads data from the provided InputStream, storing the data in DocumentBlock instances. It keeps track of the byte count as it reads the data.","tlText":"Document 从提供的 InputStream 读取数据，将数据存储在 DocumentBlock 实例中。它在读取数据时跟踪字节数。","version":0},{"id":"t_dfde676fdd754b8a8dce5513dd4cae41","oldText":"The Document creates a DocumentProperty to keep track of its property data. The byte count is stored in the newly created DocumentProperty instance.","tlText":"Document 创建一个 DocumentProperty 来跟踪其属性数据。字节数存储在新创建的 DocumentProperty 实例中。","version":0},{"id":"t_6b2e6f596eac446fb2e6c42e68ae316d","oldText":"The Filesystem requests the newly created DocumentProperty from the newly created Document instance.","tlText":"文件系统从新创建的 Document 实例请求新创建的 DocumentProperty。","version":0},{"id":"t_f1cd5ad506b740729428dade63cd313b","oldText":"The Filesystem sends the newly created DocumentProperty to the Filesystem\u0027s PropertyTable so that the PropertyTable can add the DocumentProperty to its List of Property instances.","tlText":"文件系统将新创建的 DocumentProperty 发送到文件系统的 PropertyTable，以便 PropertyTable 可以将 DocumentProperty 添加到其属性实例列表中。","version":0},{"id":"t_55bccd0a2c944d3b8fe3199462dc92d6","oldText":"The Filesystem gets the RootProperty from its PropertyTable.","tlText":"文件系统从其 PropertyTable 中获取 RootProperty。","version":0},{"id":"t_87609ca56a8041a18763f606b0393832","oldText":"The Filesystem adds the newly created DocumentProperty to the RootProperty.","tlText":"文件系统将新创建的 DocumentProperty 添加到 RootProperty。","version":0},{"id":"t_716a5f066af346dba6a9b23f9b850a47","oldText":"The Filesystem adds the PropertyTable to its List of BATManaged instances and calls the PropertyTable\u0027s preWrite method. The action taken by the PropertyTable is shown in the PropertyTable preWrite scenario diagram.","tlText":"文件系统将 PropertyTable 添加到其 BATManaged 实例列表中并调用 PropertyTable 的 preWrite 方法。 PropertyTable 采取的操作显示在 PropertyTable preWrite 场景图中。","version":0},{"id":"t_24d767e7a58d48269bfe3fe63f97a7a8","oldText":"The Filesystem creates the BlockAllocationTable.","tlText":"文件系统创建 BlockAllocationTable。","version":0},{"id":"t_0df1fd4ca62940c5a70d9e541d452f7f","oldText":"The Filesystem gets the block count from the BATManaged instance.","tlText":"文件系统从 BATManaged 实例获取块计数。","version":0},{"id":"t_df3dc9b878c042d99beded69569111f6","oldText":"These three steps are repeated for each BATManaged instance in the Filesystem\u0027s List of BATManaged instances (i.e., the Documents, in order of their addition to the Filesystem, followed by the PropertyTable).","tlText":"这三个步骤针对文件系统的 BATManaged 实例列表中的每个 BATManaged 实例（即文档，按照它们添加到文件系统的顺序，然后是 PropertyTable）重复。","version":0},{"id":"t_8a440205b7a44a52bf963cf49db090a9","oldText":"The Filesystem sends the block count to the BlockAllocationTable, which adds the appropriate entries to is IntList of entries, returning the starting block for the newly added entries.","tlText":"文件系统将块计数发送到 BlockAllocationTable，它将适当的条目添加到条目的 IntList 中，返回新添加条目的起始块。","version":0},{"id":"t_5e6f9a5a70cc472dab9c1990bc839570","oldText":"The Filesystem gives the start block number to the BATManaged instance. If the BATManaged instance is a Document, it sets the start block field in its DocumentProperty.","tlText":"文件系统将起始块编号提供给 BATManaged 实例。如果 BATManaged 实例是 Document，它会在其 DocumentProperty 中设置起始块字段。","version":0},{"id":"t_2d385910e1ac4f5685c9696f3a6ed5ed","oldText":"The Filesystem tells the BlockAllocationTable to create its BatBlocks.","tlText":"文件系统告诉 BlockAllocationTable 创建它的 BatBlocks。","version":0},{"id":"t_65a44cbccfbd424386d6c736bc6780b4","oldText":"The Filesystem gives the BAT information to the HeaderBlock so that it can set its BAT fields and, if necessary, create XBAT blocks.","tlText":"文件系统将 BAT 信息提供给 HeaderBlock，以便它可以设置其 BAT 字段，并在必要时创建 XBAT 块。","version":0},{"id":"t_98c4a2cacbe940d2baa8130803bc5a0e","oldText":"If the filesystem is unusually large (over 7MB), the HeaderBlock will create XBAT blocks to contain the BAT data that it cannot hold directly. In this case, the Filesystem tells the HeaderBlock where those additional blocks will be stored.","tlText":"如果文件系统异常大（超过 7MB），HeaderBlock 将创建 XBAT 块来包含它无法直接保存的 BAT 数据。在这种情况下，文件系统告诉 HeaderBlock 这些额外的块将被存储在哪里。","version":0},{"id":"t_9f3c0daff65a4a06928d3b33084d438f","oldText":"The Filesystem gives the PropertyTable start block to the HeaderBlock.","tlText":"文件系统将 PropertyTable 起始块提供给 HeaderBlock。","version":0},{"id":"t_e1d542986a6c4596b65a8e1d69de32c5","oldText":"The Filesystem tells the BlockWritable instance to write its blocks to the provided OutputStream. This step is repeated for each BlockWritable instance, in this order: The HeaderBlock. Each Document, in the order in which it was added to the Filesystem. The PropertyTable. The BlockAllocationTable The XBAT blocks created by the HeaderBlock, if any.","tlText":"Filesystem 告诉 BlockWritable 实例将其块写入提供的 OutputStream。对每个 BlockWritable 实例重复此步骤，顺序如下：HeaderBlock。每个文档，按照它添加到文件系统的顺序。属性表。 BlockAllocationTable 由 HeaderBlock 创建的 XBAT 块（如果有）。","version":0},{"id":"t_8722b9a832f44580894e390f0ffdcc98","oldText":"The PropertyTable calls setIndex for each of its Property instances, so that each Property now knows its index within the PropertyTable\u0027s List of Property instances.","tlText":"PropertyTable 为其每个 Property 实例调用 setIndex，以便每个 Property 现在都知道它在 PropertyTable 的 Property 实例列表中的索引。","version":0},{"id":"t_0e6b9c42600b4196b553a321c21fac4a","oldText":"The PropertyTable requests the PropertyBlock class to create an array of PropertyBlock instances.","tlText":"PropertyTable 请求 PropertyBlock 类创建一个 PropertyBlock 实例数组。","version":0},{"id":"t_8888c8c8cbab4bab9ff3586a8e22665f","oldText":"The PropertyBlock calculates the number of empty Property instances it needs to create and creates them. The algorithm for the number to create is: block_count \u003d (properties.size() + 3) / 4; emptyPropertiesNeeded \u003d (block_count * 4) - properties.size();","tlText":"PropertyBlock 计算它需要创建的空 Property 实例的数量并创建它们。创建数字的算法是：block_count \u003d (properties.size() + 3) / 4; emptyPropertiesNeeded \u003d (block_count * 4) - properties.size();","version":0},{"id":"t_83138487cd2449e4a17971967b6bd33a","oldText":"The PropertyBlock creates the required number of PropertyBlock instances from the List of Property instances, including the newly created empty Property instances.","tlText":"PropertyBlock 从 Property 实例列表中创建所需数量的 PropertyBlock 实例，包括新创建的空 Property 实例。","version":0},{"id":"t_c3975a3e5eea4ff9a571609f99d45897","oldText":"The PropertyTable calls preWrite on each of its Property instances. For DocumentProperty instances, this call is a no-op. For the RootProperty, the action taken is shown in the RootProperty preWrite scenario diagram.","tlText":"PropertyTable 在其每个 Property 实例上调用 preWrite。对于 DocumentProperty 实例，此调用是无操作的。对于 RootProperty，所采取的操作显示在 RootProperty preWrite 场景图中。","version":0},{"id":"t_5233e6d3cf1447e4b7a74ec749af7da5","oldText":"The RootProperty sets its child property with the index of the child Property that is first in its List of children.","tlText":"RootProperty 将其子属性设置为其子属性列表中第一个的子属性的索引。","version":0},{"id":"t_a689ba687f634bd582acb45999f21113","oldText":"The RootProperty sets its child\u0027s next property field with the index of the child\u0027s next sibling in the RootProperty\u0027s List of children. If the child is the last in the List, its next property field is set to -1.","tlText":"RootProperty 使用 RootProperty 的子项列表中子项的下一个兄弟的索引来设置其子项的下一个属性字段。如果孩子是列表中的最后一个，则其下一个属性字段设置为 -1。","version":0},{"id":"t_ee284abdc5f6436ca6511964810f3361","oldText":"These two steps are repeated for each File in the RootProperty\u0027s List of children.","tlText":"对 RootProperty 的子项列表中的每个文件重复这两个步骤。","version":0},{"id":"t_bfed156c1dbe476a91cefdd445eb41dc","oldText":"The RootProperty sets its child\u0027s previous property field with a value of -1.","tlText":"RootProperty 将其子项的先前属性字段设置为 -1。","version":0}]