[{"id":"t_dcafa3c01c3a4c9fac2ee545f9557566","oldText":"Record Generator HOWTO","tlText":"记录生成器 HOWTO","version":0},{"id":"t_72118ba0e9b84dc8bd2362e0a96fe49b","oldText":"How to Use the Record Generator","tlText":"如何使用记录生成器","version":0},{"id":"t_23d87a60b5f3456da4d94127e1423b72","oldText":"History","tlText":"历史","version":0},{"id":"t_7fff282a8f604742b324f1fa77100538","oldText":"Capabilities","tlText":"能力","version":0},{"id":"t_204acd0d8ba54a358846a283e630b953","oldText":"Usage","tlText":"用法","version":0},{"id":"t_7512d0b118ec4d3586e0bb01bdef6138","oldText":"Custom Field Types","tlText":"自定义字段类型","version":0},{"id":"t_6d6d495b492941b7a644f6aaa50816d9","oldText":"How it Works","tlText":"如何运行？","version":0},{"id":"t_fa74db08784646bbac4604d1d3d16829","oldText":"Limitations","tlText":"局限性","version":0},{"id":"t_f6c30423f1f54c64a3ee8c82d06ec65e","oldText":"The record generator was born from frustration with translating the Excel records to Java classes. Doing this manually is a time consuming process. It\u0027s also very easy to make mistakes.","tlText":"记录生成器是在将 Excel 记录转换为 Java 类的过程中产生的。手动执行此操作是一个耗时的过程。也很容易出错。","version":0},{"id":"t_aa4ce49228ae404cbb51d317a487152c","oldText":"A utility was needed to take the definition of what a record looked like and do all the boring and repetitive work.","tlText":"需要一个实用程序来定义记录的样子并完成所有无聊和重复的工作。","version":0},{"id":"t_962cba1c7d55497e99a5a8691ca5305d","oldText":"The record generator takes XML as input and produces the following output:","tlText":"记录生成器将 XML 作为输入并产生以下输出：","version":0},{"id":"t_518f8ee66fcc4745ae4784ed2ccebbab","oldText":"The record generator is invoked as an Ant target (generate-records). It goes through looking for all files in src/records/definitions ending with _record.xml. It then creates two files; the Java record definition and the Java test case template.","tlText":"记录生成器作为 Ant 目标调用（生成记录）。它会在 src/records/definitions 中查找以 _record.xml 结尾的所有文件。然后它创建两个文件； Java 记录定义和 Java 测试用例模板。","version":0},{"id":"t_a318d52569ef493e9ae29c2b47e4eb56","oldText":"The records themselves have the following general layout:","tlText":"记录本身具有以下总体布局：","version":0},{"id":"t_bf1dd56eb5ca4973bce854c6bccc8f8b","oldText":"The following table details the allowable types and sizes for the fields.","tlText":"下表详细说明了字段的允许类型和大小。","version":0},{"id":"t_a946d425dfcb4b23b7578f5f1d38be63","oldText":"The Java records are regenerated each time the record generator is run, however the test stubs are only created if the test stub does not already exist. What this means is that you may change test stubs but not the generated records.","tlText":"每次运行记录生成器时都会重新生成 Java 记录，但是只有在测试存根不存在时才会创建测试存根。这意味着您可以更改测试存根，但不能更改生成的记录。","version":0},{"id":"t_481c30c2733f4da594edae6a9b9ff9a6","oldText":"Occasionally the builtin types are not enough. More control over the encoding and decoding of the streams is required. This can be achieved using a custom type.","tlText":"有时内置类型是不够的。需要对流的编码和解码进行更多控制。这可以使用自定义类型来实现。","version":0},{"id":"t_c3b6b277c83d45339c368dfe4a310211","oldText":"A custom type lets you escape to java to define the way in which the field encodes and decodes. To code a custom type you declare your field like this:","tlText":"自定义类型允许您转义到 java 来定义字段编码和解码的方式。要编写自定义类型，您可以像这样声明您的字段：","version":0},{"id":"t_47b71bc86acf48bb8c88ee81c12546b0","oldText":"Where the class name specified after custom: is a class implementing the interface CustomField.","tlText":"其中custom:后面指定的类名是实现接口CustomField的类。","version":0},{"id":"t_448d952a0dbc43548484ebdfa56d82f6","oldText":"You can then implement the encoding yourself.","tlText":"然后，您可以自己实现编码。","version":0},{"id":"t_839ddd25b30c4615835d7dedf8f664da","oldText":"The record generation works by taking an XML file and styling it using XSLT. Given that XSLT is a little limited in some ways it was necessary to add a little Java code to the mix.","tlText":"记录生成是通过获取一个 XML 文件并使用 XSLT 对其进行样式设置的方式工作的。鉴于 XSLT 在某些方面受到了一些限制，因此有必要在其中添加一些 Java 代码。","version":0},{"id":"t_8761df77366d4b1cbc6b5f7891631a52","oldText":"See record.xsl, record_test.xsl, FieldIterator.java, RecordUtil.java, RecordGenerator.java","tlText":"参见record.xsl、record_test.xsl、FieldIterator.java、RecordUtil.java、RecordGenerator.java","version":0},{"id":"t_25f39e7aa54b4a87b495e03c89fb776f","oldText":"There is a corresponding \"type\" generator for HWPF. See the HWPF documentation for details.","tlText":"HWPF 有一个相应的“类型”生成器。有关详细信息，请参阅 HWPF 文档。","version":0},{"id":"t_cfa6551257dd4cd5803eb65419ec2c4e","oldText":"The record generator does not handle all possible record types and goes not intend to perform this function. When dealing with a non-standard record sometimes the cost-benefit of coding the record by hand will be greater than attempting modify the generator. The main point of the record generator is to save time, so keep that in mind.","tlText":"记录生成器不处理所有可能的记录类型并且不打算执行此功能。在处理非标准记录时，有时手动编码记录的成本效益将大于尝试修改生成器。记录生成器的主要目的是节省时间，所以请记住这一点。","version":0},{"id":"t_a9bbdce9ee3643e39ffd110e11bebcba","oldText":"Currently the the XSL file that generates the record calls out to Java objects. The Java code for the record generation is currently quite messy with minimal comments.","tlText":"目前，生成记录的 XSL 文件调用 Java 对象。用于记录生成的 Java 代码目前非常混乱，注释很少。","version":0},{"id":"t_a221500f5fb24c148acd4c817442282a","oldText":"by Glen Stampoultzis, Andrew C. Oliver","tlText":"作者：Glen Stampoultzis、Andrew C. Oliver","version":0},{"id":"t_e141e85f66bf4f1fbd7248f06a8718f8","oldText":"A Java file capable of decoding and encoding the record.","tlText":"能够对记录进行解码和编码的 Java 文件。","version":0},{"id":"t_feaa0809d0da486baad7d4298915ccd3","oldText":"A test class that provides a fill-in-the-blanks implementation of a test case for ensuring the record operates as designed.","tlText":"一个测试类，它提供测试用例的填空实现，以确保记录按设计运行。","version":0},{"id":"t_36cd00be2cb1499891aeb4a38aed03fb","oldText":"Type","tlText":"类型","version":0},{"id":"t_f438101919814d02941d8103dcdb4823","oldText":"Size","tlText":"尺寸","version":0},{"id":"t_a03a43c8852149169fd06a56822164ff","oldText":"Java Type","tlText":"Java 类型","version":0},{"id":"t_12b4065d8e2540389d6049bf4a0213ca","oldText":"int","tlText":"整数","version":0},{"id":"t_25c2643b4f404e9982efa6f8e18cf870","oldText":"1","tlText":"1","version":0},{"id":"t_921afdfeda734eafb8d6a33b9f4d02a9","oldText":"byte","tlText":"字节","version":0},{"id":"t_e42366dbb70241269766f09bcd197661","oldText":"int","tlText":"整数","version":0},{"id":"t_12bcfbcd9cf24f2da44ed27d7d7835c1","oldText":"2","tlText":"2","version":0},{"id":"t_fc862aec0ed84bdc9d82575e0128101b","oldText":"short","tlText":"短的","version":0},{"id":"t_cad108441b484fb48be7aaf4253dab7e","oldText":"int","tlText":"整数","version":0},{"id":"t_7a23f085add443de8dd0613353917586","oldText":"4","tlText":"4","version":0},{"id":"t_d79016c4c25e43c0a086cee359156845","oldText":"int","tlText":"整数","version":0},{"id":"t_d4a64f3940424b17abed5c98dc33ec2e","oldText":"int","tlText":"整数","version":0},{"id":"t_42154b552ed34885b2cf79a156027008","oldText":"8","tlText":"8","version":0},{"id":"t_0705aef5cd0947fcb0d66938baaa15ab","oldText":"long","tlText":"长","version":0},{"id":"t_7bc5319319544f99ae7918a621c7edf7","oldText":"int","tlText":"整数","version":0},{"id":"t_736b389d715b4960a2491aef45754f0f","oldText":"varword","tlText":"变量字","version":0},{"id":"t_da1aebe5f9cd493f9b0c85509cad9072","oldText":"array of shorts","tlText":"短裤阵列","version":0},{"id":"t_a44d566f76104437b42e6ab2b5fb3733","oldText":"bits","tlText":"位","version":0},{"id":"t_fc2f6d67659e4ec68e85a219423dbff2","oldText":"1","tlText":"1","version":0},{"id":"t_76f7dd1fd3b7460c81b89dbf18687533","oldText":"A byte comprising of a bits (defined by the bit element)","tlText":"由位组成的字节（由位元素定义）","version":0},{"id":"t_392f8a2a7acd4137ac54c38392296183","oldText":"bits","tlText":"位","version":0},{"id":"t_9244073627734614a5d4cb7f9ea0740a","oldText":"2","tlText":"2","version":0},{"id":"t_99fca861491a4f4d92ff2c4c801ae72d","oldText":"An short comprising of a bits","tlText":"一个由位组成的短","version":0},{"id":"t_b33b6ac8baeb4ba5b49f0ce6776907fe","oldText":"bits","tlText":"位","version":0},{"id":"t_2488d92e7f814fdcad005ab217f3155b","oldText":"4","tlText":"4","version":0},{"id":"t_8c2dcc15d0c647c2999c7036c81bbbb6","oldText":"A int comprising of a bits","tlText":"由位组成的 int","version":0},{"id":"t_a3e99f6f99e946c6b647ec28bbe6ef33","oldText":"float","tlText":"漂浮","version":0},{"id":"t_c7b62b0ee2d04634ae65e71ec3b132a9","oldText":"8","tlText":"8","version":0},{"id":"t_7423fd14489f4d978aaf1fbd0437a920","oldText":"double","tlText":"双倍的","version":0},{"id":"t_43d236d0efb04fa3a61981703ba6f364","oldText":"hbstring","tlText":"hbstring","version":0},{"id":"t_814a14358a6d42048ae97696e2cc1e07","oldText":"java expression","tlText":"java表达式","version":0},{"id":"t_be2e2b011c7848919ff8a176c81954ce","oldText":"String","tlText":"细绳","version":0}]