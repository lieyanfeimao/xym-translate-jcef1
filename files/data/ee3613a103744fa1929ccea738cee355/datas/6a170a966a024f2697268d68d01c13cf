[{"id":"t_1b1d24b202da4a1b9d6d154dd0be965e","oldText":"Excel compares numbers using different rules to those of java, so Double.compare(double, double) won\u0027t do.","tlText":"Excel将使用不同规则的数字与Java的数字进行比较，因此Double.compare（double，double）行不通。","version":0},{"id":"t_1bbc12c31fcd44bbae9a8e5d7da461d3","oldText":"This class attempts to reproduce Excel\u0027s behaviour for comparing numbers.","tlText":"本课程尝试重现Excel比较数字的行为。","version":0},{"id":"t_c76bf33b211a4d1795d267bf5bd4e5b6","oldText":"This class attempts to reproduce Excel\u0027s behaviour for comparing numbers. Results are mostly the same as those from Double.compare(double, double) but with some rounding. For numbers that are very close, this code converts to a format having 15 decimal digits of precision and a decimal exponent, before completing the comparison. In Excel formula evaluation, expressions like \"(0.06-0.01)\u003d0.05\" evaluate to \"TRUE\" even though the equivalent java expression is false. In examples like this, Excel achieves the effect by having additional logic for comparison operations. Note - Excel also gives special treatment to expressions like \"0.06-0.01-0.05\" which evaluates to \"0\" (in java, rounding anomalies give a result of 6.9E-18). The special behaviour here is for different reasons to the example above: If the last operator in a cell formula is \u0027+\u0027 or \u0027-\u0027 and the result is less than 250 times smaller than first operand, the result is rounded to zero. Needless to say, the two rules are not consistent and it is relatively easy to find examples that satisfy \"A\u003dB\" is \"TRUE\" but \"A-B\" is not \"0\" and \"A\u003dB\" is \"FALSE\" but \"A-B\" is \"0\" This rule (for rounding the result of a final addition or subtraction), has not been implemented in POI (as of Jul-2009).","tlText":"本课程尝试重现Excel比较数字的行为。结果大多与Double.compare上的结果相同（双倍，双倍），但有一些四舍五入。对于非常接近的数字，在完成比较之前，此代码将转换为具有15个小数精度和小数指数的格式。在Excel公式计算中，即使等效的Java表达为假，“（0.06-0.01）\u003d0.05”等表达也会计算为“True”。在这样的示例中，Excel通过为比较操作提供额外的逻辑来实现效果。注意- Excel还对计算结果为“0”的“0.06-0.01-0.05”等表达方式进行特殊处理（在Java中，四舍五入异常会得到6.9E-18的结果）。这里的特殊行为与上面的例子不同的原因：如果单元格公式中的最后一个运算符是“+”或“-”，并且结果比第一个操作数小不到250倍，则结果将四舍五入为零。不用说，这两个规则并不一致，并且相对容易找到满足“A\u003dB”是“真”但“A-B”不是“0”且“A\u003dB”是“RST”但“A-B”是“0”的例子该规则（用于对最终加法或减法的结果进行四舍五入）尚未在PRI中实现（截至2009年7月）。","version":0},{"id":"t_9f93bd23c1e941009053e030c945d702","oldText":"negative, 0, or positive according to the standard Excel comparison of values a and b.","tlText":"根据值a和b的标准Excel比较，为负、0或正。","version":0}]