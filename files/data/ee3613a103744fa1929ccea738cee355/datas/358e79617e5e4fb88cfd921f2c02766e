[{"id":"t_6235c09baa75457d957787fe721db538","oldText":"A decorated RecordInputStream that can read primitive data types (short, int, long, etc.) spanned across a ContinueRecord boundary. Most records construct themselves from RecordInputStream. This class assumes that a ContinueRecord record break always occurs at the type boundary, however, it is not always so. Two attachments to Bugzilla 50779 demonstrate that a CONTINUE break can appear right in between two bytes of a unicode character or between two bytes of a short. The problematic portion of the data is in a Asian Phonetic Settings Block (ExtRst) of a UnicodeString. RecordInputStream greedily requests the bytes to be read and stumbles on such files with a \"Not enough data (1) to read requested (2) bytes\" exception. The ContinuableRecordInput class circumvents this \"type boundary\" rule and reads data byte-by-byte rolling over CONTINUE if necessary. YK: For now (March 2011) this class is only used to read","tlText":"经过修饰的RecordInputStream，可以读取原始数据类型（Short、int、Long等）跨越ContinueRecord边界。大多数记录都是从RecordInputStream中构建的。此类假设ContinueRecord记录中断总是发生在类型边界，然而，事实并非总是如此。Bugzilla 50779的两个附件证明，继续中断可以出现在unicode字符的两个字节之间或Short字符的两个字节之间。数据中有问题的部分位于Unicode字符串的亚洲音素设置块（ExtRst）中。RecordInputStream贪婪地请求读取字节，并在此类文件上遇到“没有足够的数据（1）来读取请求的（2）字节”异常。ContinuableRecordEnter类绕过了此“类型边界”规则，并在必要时逐字节滚动读取数据。JK：目前（2011年3月）这门课仅用于阅读","version":0},{"id":"t_11299545da344322aed407f61e146279","oldText":"Usually acts the same as LittleEndianInput.readFully(byte[], int, int), but for an encrypted stream the raw (unencrypted) data is filled","tlText":"通常作用与LittleEndianInvestment.readFully（byte[]，int，int）相同，但对于加密流，原始（未加密）数据将被填充","version":0},{"id":"t_17c4b185091c4fc286d5c2e134defbec","oldText":"available in interface LittleEndianInput","tlText":"可在LittleEndianConnect界面中使用","version":0},{"id":"t_4bea1c93a16c403d9dcaf5f33d248106","oldText":"readByte in interface LittleEndianInput","tlText":"LittleEndianConnect接口中的读取字节","version":0},{"id":"t_4324baedf17d4ea6a9aec5ed07176de0","oldText":"readUByte in interface LittleEndianInput","tlText":"在接口LittleEndianInvestment中读取UByte","version":0},{"id":"t_b13a34d22fd6499bbdee2cb625ee3fa7","oldText":"readShort in interface LittleEndianInput","tlText":"在界面中读取Short LittleEndianInvestment","version":0},{"id":"t_ab7da416d9ff42c78ea14bbb25e3ace7","oldText":"readUShort in interface LittleEndianInput","tlText":"readU接口中的短路LittleEndianInput","version":0},{"id":"t_5aa0e128a4234766bf927b0edc65b505","oldText":"readInt in interface LittleEndianInput","tlText":"在界面LittleEndianInvestment中读取Int","version":0},{"id":"t_514933c2f0df43dd86fcf3ca6cc365a5","oldText":"readLong in interface LittleEndianInput","tlText":"在界面中读长LittleEndianInvestment","version":0},{"id":"t_c8ba8dfe51704fb4a4da337f86b2ebbd","oldText":"readDouble in interface LittleEndianInput","tlText":"在界面LittleEndianInvestment中读取Double","version":0},{"id":"t_ab598a498ef3448bb349316e42141b67","oldText":"readFully in interface LittleEndianInput","tlText":"在界面LittleEndianInvestment中完全阅读","version":0},{"id":"t_e01a6718e4ea46e4b31a8b35e077f9e7","oldText":"readFully in interface LittleEndianInput","tlText":"在界面LittleEndianInvestment中完全阅读","version":0},{"id":"t_7b22d05d897840a7a013f79f29923a44","oldText":"Usually acts the same as LittleEndianInput.readFully(byte[], int, int), but for an encrypted stream the raw (unencrypted) data is filled","tlText":"通常作用与LittleEndianInvestment.readFully（byte[]，int，int）相同，但对于加密流，原始（未加密）数据将被填充","version":0},{"id":"t_fba8331a7b974be8ad2033ff3bb30d2d","oldText":"readPlain in interface LittleEndianInput","tlText":"readPlain在接口LittleEndianInput中","version":0},{"id":"t_f122f66dda2243c29c598fb9b9396895","oldText":"buf - the byte array to receive the bytes","tlText":"buf -接收字节的字节数组","version":0},{"id":"t_b3d76f7df0d74b8695bec9177b83482d","oldText":"off - the start offset into the byte array","tlText":"off -字节数组的开始偏差","version":0},{"id":"t_5fb5cb815b654d539ebf150b0ab094b0","oldText":"len - the amount of bytes to fill","tlText":"len -要填充的字节量","version":0}]