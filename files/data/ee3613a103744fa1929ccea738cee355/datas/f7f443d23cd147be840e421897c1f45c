[{"id":"t_0da0acca586e4d10a0cd0c1a05b000c5","oldText":"Helper functions used for standard and agile encryption","tlText":"用于标准和敏捷加密的助手功能","version":0},{"id":"t_7e45e7fbac6d4e7b949eb13fb9d58786","oldText":"Creates an byte array for xor obfuscation (method 1)","tlText":"创建用于异或混淆的字节数组（方法1）","version":0},{"id":"t_eeccd4cc49e346538a3677ae68260ac7","oldText":"Create the xor key for xor obfuscation, which is used to create the xor array (method 1)","tlText":"为XOR模糊处理创建XOR键，该键用于创建XOR数组（方法1）","version":0},{"id":"t_a1a94c5633e44f43b8e811504d3d1928","oldText":"Create the verifier for xor obfuscation (method 1)","tlText":"创建异或混淆的验证器（方法1）","version":0},{"id":"t_29e6fafb81244751b51329f09dbe0e6f","oldText":"This method generates the xor verifier for word documents \u003c 2007 (method 2).","tlText":"此方法为word文档\u003c 2007生成异或验证器（方法2）。","version":0},{"id":"t_9d586486c2324cbf940b278a97a0ac22","oldText":"2.3.4.12 Initialization Vector Generation (Agile Encryption)","tlText":"2.3.4.12收件箱载体生成（敏捷加密）","version":0},{"id":"t_947bff816b9247049b1cf83ae71984ba","oldText":"2.3.4.11 Encryption Key Generation (Agile Encryption)","tlText":"2.3.4.11加密密钥生成（敏捷加密）","version":0},{"id":"t_40a3271d5e56498bbae1d6696e95f2e0","oldText":"Returns a new byte array with a truncated to the given size.","tlText":"返回一个新的字节数组，并已被截断为给定大小。","version":0},{"id":"t_fdd8f5e7245b46d9be6bd2f150f19453","oldText":"Initialize a new cipher object with the given cipher properties If the given algorithm is not implemented in the JCE, it will try to load it from the bouncy castle provider.","tlText":"使用给定的密码属性初始化新的密码对象如果给定的算法没有在JCE中实现，则它将尝试从弹跳城堡提供程序加载它。","version":0},{"id":"t_bb7b806905f04c8ba4e4550c77041020","oldText":"Initialize a new cipher object with the given cipher properties and no padding If the given algorithm is not implemented in the JCE, it will try to load it from the bouncy castle provider.","tlText":"使用给定的密码属性且无填充初始化新的密码对象如果给定的算法没有在JCE中实现，则它将尝试从弹跳城堡提供程序加载它。","version":0},{"id":"t_2649a8ac603e4cdc9bdacd60a963f986","oldText":"2.3.4.7 ECMA-376 Document Encryption Key Generation (Standard Encryption) 2.3.4.11 Encryption Key Generation (Agile Encryption)","tlText":"2.3.4.7 ECMA-376文档加密密钥生成（标准加密）2.3.4.11加密密钥生成（敏捷加密）","version":0},{"id":"t_46375337aa3544278751a03f9fb9e700","oldText":"Generalized method for read and write protection hash generation.","tlText":"读写保护哈希生成的通用方法。","version":0},{"id":"t_eddb581446994c2184b36112ed2245c9","oldText":"This method generates the xored-hashed password for word documents \u003c 2007.","tlText":"此方法为word文档\u003c 2007生成xored哈希密码。","version":0},{"id":"t_b19ff38fa4e64431acbb33b32fff2e74","oldText":"Convenience function which returns the reversed xored-hashed password for further processing in word documents 2007 and newer, which utilize a real hashing algorithm like sha1.","tlText":"便利函数，返回反向异列哈希密码，以在word文档2007及更新版本中进一步处理，这些文档利用了sha 1等真正的哈希算法。","version":0},{"id":"t_a043438d6f2c4cbea2f61ffbddeec35b","oldText":"2.3.4.7 ECMA-376 Document Encryption Key Generation (Standard Encryption) 2.3.4.11 Encryption Key Generation (Agile Encryption) The encryption key for ECMA-376 document encryption [ECMA-376] using agile encryption MUST be generated by using the following method, which is derived from PKCS #5: Password-Based Cryptography Version 2.0 [RFC2898]. Let H() be a hashing algorithm as determined by the PasswordKeyEncryptor.hashAlgorithm element, H_n be the hash data of the n-th iteration, and a plus sign (+) represent concatenation. The password MUST be provided as an array of Unicode characters. Limitations on the length of the password and the characters used by the password are implementation-dependent. The initial password hash is generated as follows: H_0 \u003d H(salt + password) The salt used MUST be generated randomly. The salt MUST be stored in the PasswordKeyEncryptor.saltValue element contained within the \\EncryptionInfo stream as specified in section 2.3.4.10. The hash is then iterated by using the following approach: H_n \u003d H(iterator + H_n-1) where iterator is an unsigned 32-bit value that is initially set to 0x00000000 and then incremented monotonically on each iteration until PasswordKey.spinCount iterations have been performed. The value of iterator on the last iteration MUST be one less than PasswordKey.spinCount. For POI, H_final will be calculated by generateKey(byte[],HashAlgorithm,byte[],int)","tlText":"2.3.4.7 ECMA-376文档加密密钥生成（标准加密）2.3.4.11加密密钥生成（敏捷加密）使用敏捷加密的ECMA-376文档加密[ECMA-376]的加密密钥必须通过使用以下方法生成，该方法源自PKCS #5：基于密码的加密术版本2.0 [RFC 2898]。令H（）是由PasswordKeyCryptor. hashAlomon元素确定的哈希算法，H_n是第n次迭代的哈希数据，而正号（+）表示级联。密码必须以Unicode字符数组的形式提供。密码长度和密码使用的字符的限制取决于实现。初始密码哈希如下生成：H_0 \u003d H（salt +口令）使用的salt必须随机生成。盐必须存储在\\Protect流中包含的PasswordKeyProtect.saltValue元素中，如第2.3.4.10节中指定的。然后使用以下方法迭代哈希值：H_n \u003d H（迭代器+ H_n-1）其中迭代器是一个无符号的32位值，最初设置为0x 0000000，然后在每次迭代中单调增加，直到执行PasswordKey.spinCount迭代。最后一次迭代的迭代器值必须比PasswordKey. spinCount小一。对于兴趣点，H_final将通过generateKey（byte[]，HashAl算法，byte[]，int）计算","version":0},{"id":"t_054ef39ae8f14b6b87e4ac362e6002cf","oldText":"password - the password","tlText":"密码-密码","version":0},{"id":"t_c38a67db8e69428d844cd990aa35f6f0","oldText":"hashAlgorithm - the hash algorithm","tlText":"哈希算法-哈希算法","version":0},{"id":"t_9d91b6fb15f648bca47a7a2680d1f711","oldText":"salt - the initial salt value","tlText":"盐--初始盐值","version":0},{"id":"t_f7eaa11cef2849129198854229b3dd21","oldText":"spinCount - the repetition count","tlText":"spinCount -重复计数","version":0},{"id":"t_ec60e2cce91d4894822510882ebabd9f","oldText":"the hashed password","tlText":"哈希密码","version":0},{"id":"t_f6535092f00f4ae886afa0eff4a70d34","oldText":"Generalized method for read and write protection hash generation. The difference is, read protection uses the order iterator then hash in the hash loop, whereas write protection uses first the last hash value and then the current iterator value","tlText":"读写保护哈希生成的通用方法。不同之处在于，读保护使用顺序迭代器，然后在哈希循环中使用哈希，而写保护首先使用最后一个哈希值，然后使用当前迭代器值","version":0},{"id":"t_d34658b7467d4f07b5779594ba098ab4","oldText":"password - the pasword","tlText":"密码-密码","version":0},{"id":"t_4939b12c2046412c955b5b19e7f7ec55","oldText":"hashAlgorithm - the hash algorighm","tlText":"哈希算法-哈希算法","version":0},{"id":"t_d1edeb6ce5f3491f99142e70b6bee38d","oldText":"salt - the initial salt value","tlText":"盐--初始盐值","version":0},{"id":"t_e4f2c589eda3440c8fab4e358f6c1d12","oldText":"spinCount - the repetition count","tlText":"spinCount -重复计数","version":0},{"id":"t_9d9b1bc0a9ac4da5832f3ee262ed65c0","oldText":"iteratorFirst - if true, the iterator is hashed before the n-1 hash value, if false the n-1 hash value is applied first","tlText":"iteratorFirst -如果为真，则在n-1哈希值之前对迭代器进行哈希处理，如果为假，则首先应用n-1哈希值","version":0},{"id":"t_d839cc129c5d4fa6bb28cc84ad42b7de","oldText":"the hashed password","tlText":"哈希密码","version":0},{"id":"t_bf8133974b364b7cbd3d9a68157ca0f6","oldText":"2.3.4.12 Initialization Vector Generation (Agile Encryption) Initialization vectors are used in all cases for agile encryption. An initialization vector MUST be generated by using the following method, where H() is a hash function that MUST be the same as specified in section 2.3.4.11 and a plus sign (+) represents concatenation: If a blockKey is provided, let IV be a hash of the KeySalt and the following value: blockKey: IV \u003d H(KeySalt + blockKey) If a blockKey is not provided, let IV be equal to the following value: KeySalt:IV \u003d KeySalt If the number of bytes in the value of IV is less than the the value of the blockSize attribute corresponding to the cipherAlgorithm attribute, pad the array of bytes by appending 0x36 until the array is blockSize bytes. If the array of bytes is larger than blockSize bytes, truncate the array to blockSize bytes.","tlText":"2.3.4.12加密矢量生成（敏捷加密）加密矢量在所有情况下都用于敏捷加密。必须使用以下方法生成初始化向量，其中H（）是一个哈希函数，必须与2.3.4.11节中指定的相同，加号（+）表示串联：如果提供了blockKey，则让IV是KeySalt的哈希值，并具有以下值：blockKey：IV \u003d H（KeySalt + blockKey）如果未提供blockKey，则让IV等于以下值：KeySalt：IV \u003d KeySalt如果IV值中的字节数小于对应于cipherAlgorithm属性的blockSize属性的值，则通过附加0x36来填充字节数组，直到数组为blockSize字节。如果字节数组大于blockSize bytes，则将数组截断为blockSize bytes。","version":0},{"id":"t_4e5c175509644d10835742a2d5a0b392","oldText":"2.3.4.11 Encryption Key Generation (Agile Encryption) The final hash data that is used for an encryption key is then generated by using the following method: H_final \u003d H(H_n + blockKey) where blockKey represents an array of bytes used to prevent two different blocks from encrypting to the same cipher text. If the size of the resulting H_final is smaller than that of PasswordKeyEncryptor.keyBits, the key MUST be padded by appending bytes with a value of 0x36. If the hash value is larger in size than PasswordKeyEncryptor.keyBits, the key is obtained by truncating the hash value.","tlText":"2.3.4.11加密密钥生成（敏捷加密）然后通过使用以下方法生成用于加密密钥的最终哈希数据：H_final \u003d H（H_n + blockKey）其中blockKey表示用于防止两个不同块加密为相同密文的字节数组。如果结果H_final的大小小于PasswordKeyProtect.keyBits的大小，则必须通过添加值0x 36的字节来填充密钥。如果哈希值的大小大于PasswordKeyCryptor.keyBits，则通过截断哈希值来获得密钥。","version":0},{"id":"t_0a591acd47854de1a830eb0294f5f8f2","oldText":"passwordHash - the hashed password byte","tlText":"password哈希-哈希密码字节","version":0},{"id":"t_a624a05355574fc8a5c04caa06a13206","oldText":"hashAlgorithm - the hash algorithm","tlText":"哈希算法-哈希算法","version":0},{"id":"t_c03d0821402c4eb3a293c1b24af8043a","oldText":"blockKey - the block key","tlText":"blockKey -块密钥","version":0},{"id":"t_2e593eb6652745b7aa557bb8a614ce73","oldText":"keySize - the key size","tlText":"keySize -密钥大小","version":0},{"id":"t_68f274dfce014a0da0aa338f2308143e","oldText":"intermediate key","tlText":"中间密钥","version":0},{"id":"t_e39b5c49563345fa8b42cbf965d31b64","oldText":"Initialize a new cipher object with the given cipher properties and no padding If the given algorithm is not implemented in the JCE, it will try to load it from the bouncy castle provider.","tlText":"使用给定的密码属性且无填充初始化新的密码对象如果给定的算法没有在JCE中实现，则它将尝试从弹跳城堡提供程序加载它。","version":0},{"id":"t_0a3bfb5cbc6745aa982c6a788aaffd86","oldText":"key - the secret key","tlText":"钥匙-秘密钥匙","version":0},{"id":"t_8e96a017613048bda44d13bcc6372031","oldText":"cipherAlgorithm - the cipher algorithm","tlText":"密码算法-密码算法","version":0},{"id":"t_8c99b4e4e1e74b0a889a3ab4d9d0a024","oldText":"chain - the chaining mode","tlText":"链-链模式","version":0},{"id":"t_067c4c6a2c934bcfb882b5472d0f700f","oldText":"vec - the initialization vector (IV), can be null","tlText":"vec -初始化载体（IV），可以为空","version":0},{"id":"t_24e5e1e9178b4559af1ed4cff93c0efa","oldText":"cipherMode - Cipher.DECRYPT_MODE or Cipher.ENCRYPT_MODE","tlText":"cipherMode - Cipher. DESYS PT_Mode或Cipher. ENSYS PT_Mode","version":0},{"id":"t_52d127f73c8e474d8fd29498cfc3b1dc","oldText":"the requested cipher","tlText":"所请求的密码","version":0},{"id":"t_c85b635a5fbd4406beeeb55c640f571d","oldText":"EncryptedDocumentException - if the initialization failed or if an algorithm was specified, which depends on a missing bouncy castle provider","tlText":"EncryptedDocumentException -如果初始化失败或如果指定了算法，这取决于缺少弹性城堡提供程序","version":0},{"id":"t_8f4b777c1fef4677a04be8637d266b4b","oldText":"Initialize a new cipher object with the given cipher properties If the given algorithm is not implemented in the JCE, it will try to load it from the bouncy castle provider.","tlText":"使用给定的密码属性初始化新的密码对象如果给定的算法没有在JCE中实现，则它将尝试从弹跳城堡提供程序加载它。","version":0},{"id":"t_17df6ffb7bff4e53b7cd2de827f54680","oldText":"key - the secret key","tlText":"钥匙-秘密钥匙","version":0},{"id":"t_81638ecdd34c46588673607d92acb761","oldText":"cipherAlgorithm - the cipher algorithm","tlText":"密码算法-密码算法","version":0},{"id":"t_1107723cb30e4e5a99693e0f3c53f4aa","oldText":"chain - the chaining mode","tlText":"链-链模式","version":0},{"id":"t_8ecf09cd28794966a3975d956e60c9cb","oldText":"vec - the initialization vector (IV), can be null","tlText":"vec -初始化载体（IV），可以为空","version":0},{"id":"t_4b16a590b3bb4cd98612d1f6062cf09e","oldText":"cipherMode - Cipher.DECRYPT_MODE or Cipher.ENCRYPT_MODE","tlText":"cipherMode - Cipher. DESYS PT_Mode或Cipher. ENSYS PT_Mode","version":0},{"id":"t_12c5ed1050334746972b016a8c86c7b3","oldText":"padding - the padding (null \u003d NOPADDING, ANSIX923Padding, PKCS5Padding, PKCS7Padding, ISO10126Padding, ...)","tlText":"填充-填充（空\u003d NOPADDING、ANSIX 923填充、PKCS 5填充、PKCS 7填充、ISO 10126填充、.）","version":0},{"id":"t_fb404523ecfa4c4db192104872b34836","oldText":"the requested cipher","tlText":"所请求的密码","version":0},{"id":"t_245588ada2d24dff9b3604762eb41de1","oldText":"EncryptedDocumentException - if the initialization failed or if an algorithm was specified, which depends on a missing bouncy castle provider","tlText":"EncryptedDocumentException -如果初始化失败或如果指定了算法，这取决于缺少弹性城堡提供程序","version":0},{"id":"t_2b72fc59f1444ea08304de4057ac0d74","oldText":"Returns a new byte array with a truncated to the given size. If the hash has less then size bytes, it will be filled with 0-bytes","tlText":"返回一个新的字节数组，并已被截断为给定大小。如果哈希的字节小于大小，则将用0字节填充","version":0},{"id":"t_a5d779e7d3414fb4b608736f5e22d957","oldText":"hash - the to be truncated/filled hash byte array","tlText":"哈希-要被截断/填充的哈希字节数组","version":0},{"id":"t_621f2152da654bd08b76cb86cf38b86c","oldText":"size - the size of the returned byte array","tlText":"size -返回的字节数组的大小","version":0},{"id":"t_a928c1d6369a440f9b5b78fb9d7c7e70","oldText":"the padded hash","tlText":"填充哈希","version":0},{"id":"t_e522eaaebcc64224ab35315da5f20e63","oldText":"Create the verifier for xor obfuscation (method 1)","tlText":"创建异或混淆的验证器（方法1）","version":0},{"id":"t_1455682b91014a119dab83773effcbe5","oldText":"password - the password","tlText":"密码-密码","version":0},{"id":"t_cb70a8af36ce452d8bb85ea578d2df97","oldText":"the verifier (actually a short value)","tlText":"验证器（实际上是一个短值）","version":0},{"id":"t_8048c2db1bcb4fa4b207ce7a1b2bc947","oldText":"This method generates the xor verifier for word documents \u003c 2007 (method 2). Its output will be used as password input for the newer word generations which utilize a real hashing algorithm like sha1.","tlText":"此方法为word文档\u003c 2007生成异或验证器（方法2）。它的输出将用作新单词世代的密码输入，这些单词世代使用真正的哈希算法，例如sha 1。","version":0},{"id":"t_b8279fe9771c4ba68f77dd89ce458658","oldText":"password - the password","tlText":"密码-密码","version":0},{"id":"t_ce1c76707ec3482db0b54d6c669d5db6","oldText":"the hashed password","tlText":"哈希密码","version":0},{"id":"t_425a06bd49704325ba1b26ac2eeff7b6","oldText":"This method generates the xored-hashed password for word documents \u003c 2007.","tlText":"此方法为word文档\u003c 2007生成xored哈希密码。","version":0},{"id":"t_72dac4fb573e4f5ca427b38d6e0f98e4","oldText":"Convenience function which returns the reversed xored-hashed password for further processing in word documents 2007 and newer, which utilize a real hashing algorithm like sha1.","tlText":"便利函数，返回反向异列哈希密码，以在word文档2007及更新版本中进一步处理，这些文档利用了sha 1等真正的哈希算法。","version":0},{"id":"t_70fa0ea0d97c499a89ad97ab958550df","oldText":"Create the xor key for xor obfuscation, which is used to create the xor array (method 1)","tlText":"为XOR模糊处理创建XOR键，该键用于创建XOR数组（方法1）","version":0},{"id":"t_9cb2fda272a445a89f14dd8105cc7e33","oldText":"password - the password","tlText":"密码-密码","version":0},{"id":"t_6ccc37aa60d0403eb638c9b399d971c2","oldText":"the xor key","tlText":"异或键","version":0},{"id":"t_b0c2ab11692f4a5b8a539339d4287287","oldText":"Creates an byte array for xor obfuscation (method 1)","tlText":"创建用于异或混淆的字节数组（方法1）","version":0},{"id":"t_49bbc3e1be224e9f970d5c8faad7e15b","oldText":"password - the password","tlText":"密码-密码","version":0},{"id":"t_3eb576acdeb140f085f50f44eedab74f","oldText":"the byte array for xor obfuscation","tlText":"用于异或混淆的字节数组","version":0}]