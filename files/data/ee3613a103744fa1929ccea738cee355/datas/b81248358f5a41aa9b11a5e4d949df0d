[{"id":"t_e1ca7bc0924049b38033c10c94e230b5","oldText":"Common superclass of all records that can produce ContinueRecords while being serialized.","tlText":"序列化时可以生成ContinueRecords的所有记录的公共超类。","version":0},{"id":"t_aa285ecdf7db4c9daafcf8a32751ea2c","oldText":"gives the current serialized size of the record.","tlText":"给出记录的当前序列化大小。","version":0},{"id":"t_19e9c719d8d94b3a86e3131a188b8fac","oldText":"Serializes this record\u0027s content to the supplied data output.","tlText":"将此记录的内容序列化为提供的数据输出。","version":0},{"id":"t_d12a25067cf34683a071faf97d6eb33a","oldText":"called by the class that is responsible for writing this sucker.","tlText":"由负责编写这个傻瓜的类调用。","version":0},{"id":"t_06ff78ef08c24a94b66bccaf901f988a","oldText":"Serializes this record\u0027s content to the supplied data output. The standard BIFF header (ushort sid, ushort size) has been handled by the superclass, so only BIFF data should be written by this method. Simple data types can be written with the standard LittleEndianOutput methods. Methods from ContinuableRecordOutput can be used to serialize strings (with ContinueRecords being written as required). If necessary, implementors can explicitly start ContinueRecords (regardless of the amount of remaining space).","tlText":"将此记录的内容序列化为提供的数据输出。标准BIFF标头（ushort sid、ushort size）已由超类处理，因此该方法只应该编写BIFF数据。简单的数据类型可以使用标准的LittleEndianExit方法编写。ContinuableRecordExit中的方法可用于序列化字符串（根据需要编写ContinueRecords）。如有必要，实现者可以显式启动ContinueRecords（无论剩余空间多少）。","version":0},{"id":"t_8042749c5712479e9959612aefc9665c","oldText":"out - a data output stream","tlText":"out -数据输出流","version":0},{"id":"t_9b4cafe265fa4572ac4d8ca2e8ba13ca","oldText":"gives the current serialized size of the record. Should include the sid and reclength (4 bytes).","tlText":"给出记录的当前序列化大小。应包括sid和recsize（4个字节）。","version":0},{"id":"t_a71a8ce184d64d70aa6369e3b7ef7178","oldText":"getRecordSize in class RecordBase","tlText":"RecordBase类中的getRecordSize","version":0},{"id":"t_c3a1444476b8455b84158f009f53f2a6","oldText":"the total length of the encoded record(s) (Note - if any ContinueRecord is required, this result includes the size of those too)","tlText":"编码记录的总长度（注意-如果需要任何ContinueRecord，此结果也包括这些记录的大小）","version":0},{"id":"t_e4b126f1072b4638b013dc059c58df3d","oldText":"called by the class that is responsible for writing this sucker. Subclasses should implement this so that their data is passed back in a byte array.","tlText":"由负责编写这个傻瓜的类调用。子类应该实现这一点，以便它们的数据以字节数组的形式传递回。","version":0},{"id":"t_474c642c6174480797d419354d763488","oldText":"serialize in class RecordBase","tlText":"在RecordBase类中序列化","version":0},{"id":"t_c3c25d65e6864bfcb8b784a5bb0ca281","oldText":"offset - to begin writing at","tlText":"抵消-开始写作","version":0},{"id":"t_8e40703847f643d69e3f26a28a5a333d","oldText":"data - byte array containing instance data","tlText":"data -包含实例数据的字节数组","version":0},{"id":"t_51e2b88badf448b09e99650e2a4d9365","oldText":"number of bytes written","tlText":"写入的字节数","version":0}]