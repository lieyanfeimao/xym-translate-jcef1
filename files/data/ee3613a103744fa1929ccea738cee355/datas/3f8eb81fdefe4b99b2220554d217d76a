[{"id":"t_a80fded55f6842e7b0c788a7c3a25fd1","oldText":"This class is used to simplify error handling logic within operator and function implementations. Note - OperationEval.evaluate() and Function.evaluate() method signatures do not throw this exception so it cannot propagate outside. Here is an example coded without EvaluationException, to show how it can help:  public Eval evaluate(Eval[] args, int srcRow, short srcCol) {\n        // ...\n        Eval arg0 \u003d args[0];\n        if(arg0 instanceof ErrorEval) {\n                return arg0;\n        }\n        if(!(arg0 instanceof AreaEval)) {\n                return ErrorEval.VALUE_INVALID;\n        }\n        double temp \u003d 0;\n        AreaEval area \u003d (AreaEval)arg0;\n        ValueEval[] values \u003d area.getValues();\n        for (int i \u003d 0; i \u003c values.length; i++) {\n                ValueEval ve \u003d values[i];\n                if(ve instanceof ErrorEval) {\n                        return ve;\n                }\n                if(!(ve instanceof NumericValueEval)) {\n                        return ErrorEval.VALUE_INVALID;\n                }\n                temp +\u003d ((NumericValueEval)ve).getNumberValue();\n        }\n        // ...\n }       \n In this example, if any error is encountered while processing the arguments, an error is returned immediately. This code is difficult to refactor due to all the points where errors are returned. Using EvaluationException allows the error returning code to be consolidated to one place.  public Eval evaluate(Eval[] args, int srcRow, short srcCol) {\n        try {\n                // ...\n                AreaEval area \u003d getAreaArg(args[0]);\n                double temp \u003d sumValues(area.getValues());\n                // ...\n        } catch (EvaluationException e) {\n                return e.getErrorEval();\n        }\n}\n\nprivate static AreaEval getAreaArg(Eval arg0) throws EvaluationException {\n        if (arg0 instanceof ErrorEval) {\n                throw new EvaluationException((ErrorEval) arg0);\n        }\n        if (arg0 instanceof AreaEval) {\n                return (AreaEval) arg0;\n        }\n        throw EvaluationException.invalidValue();\n}\n\nprivate double sumValues(ValueEval[] values) throws EvaluationException {\n        double temp \u003d 0;\n        for (int i \u003d 0; i \u003c values.length; i++) {\n                ValueEval ve \u003d values[i];\n                if (ve instanceof ErrorEval) {\n                        throw new EvaluationException((ErrorEval) ve);\n                }\n                if (!(ve instanceof NumericValueEval)) {\n                        throw EvaluationException.invalidValue();\n                }\n                temp +\u003d ((NumericValueEval) ve).getNumberValue();\n        }\n        return temp;\n}\n It is not mandatory to use EvaluationException, doing so might give the following advantages: - Methods can more easily be extracted, allowing for re-use. - Type management (typecasting etc) is simpler because error conditions have been separated from intermediate calculation values. - Fewer local variables are required. Local variables can have stronger types. - It is easier to mimic common Excel error handling behaviour (exit upon encountering first error), because exceptions conveniently propagate up the call stack regardless of execution points or the number of levels of nested calls. Note - Only standard evaluation errors are represented by EvaluationException ( i.e. conditions expected to be encountered when evaluating arbitrary Excel formulas). Conditions that could never occur in an Excel spreadsheet should result in runtime exceptions. Care should be taken to not translate any POI internal error into an Excel evaluation error code.","tlText":"This class is used to simplify error handling logic within operator and function implementations. Note - OperationEval.evaluate() and Function.evaluate() method signatures do not throw this exception so it cannot propagate outside. Here is an example coded without EvaluationException, to show how it can help:  public Eval evaluate(Eval[] args, int srcRow, short srcCol) {\n        // ...\n        Eval arg0 \u003d args[0];\n        if(arg0 instanceof ErrorEval) {\n                return arg0;\n        }\n        if(!(arg0 instanceof AreaEval)) {\n                return ErrorEval.VALUE_INVALID;\n        }\n        double temp \u003d 0;\n        AreaEval area \u003d (AreaEval)arg0;\n        ValueEval[] values \u003d area.getValues();\n        for (int i \u003d 0; i \u003c values.length; i++) {\n                ValueEval ve \u003d values[i];\n                if(ve instanceof ErrorEval) {\n                        return ve;\n                }\n                if(!(ve instanceof NumericValueEval)) {\n                        return ErrorEval.VALUE_INVALID;\n                }\n                temp +\u003d ((NumericValueEval)ve).getNumberValue();\n        }\n        // ...\n }       \n In this example, if any error is encountered while processing the arguments, an error is returned immediately. This code is difficult to refactor due to all the points where errors are returned. Using EvaluationException allows the error returning code to be consolidated to one place.  public Eval evaluate(Eval[] args, int srcRow, short srcCol) {\n        try {\n                // ...\n                AreaEval area \u003d getAreaArg(args[0]);\n                double temp \u003d sumValues(area.getValues());\n                // ...\n        } catch (EvaluationException e) {\n                return e.getErrorEval();\n        }\n}\n\nprivate static AreaEval getAreaArg(Eval arg0) throws EvaluationException {\n        if (arg0 instanceof ErrorEval) {\n                throw new EvaluationException((ErrorEval) arg0);\n        }\n        if (arg0 instanceof AreaEval) {\n                return (AreaEval) arg0;\n        }\n        throw EvaluationException.invalidValue();\n}\n\nprivate double sumValues(ValueEval[] values) throws EvaluationException {\n        double temp \u003d 0;\n        for (int i \u003d 0; i \u003c values.length; i++) {\n                ValueEval ve \u003d values[i];\n                if (ve instanceof ErrorEval) {\n                        throw new EvaluationException((ErrorEval) ve);\n                }\n                if (!(ve instanceof NumericValueEval)) {\n                        throw EvaluationException.invalidValue();\n                }\n                temp +\u003d ((NumericValueEval) ve).getNumberValue();\n        }\n        return temp;\n}\n It is not mandatory to use EvaluationException, doing so might give the following advantages: - Methods can more easily be extracted, allowing for re-use. - Type management (typecasting etc) is simpler because error conditions have been separated from intermediate calculation values. - Fewer local variables are required. Local variables can have stronger types. - It is easier to mimic common Excel error handling behaviour (exit upon encountering first error), because exceptions conveniently propagate up the call stack regardless of execution points or the number of levels of nested calls. Note - Only standard evaluation errors are represented by EvaluationException ( i.e. conditions expected to be encountered when evaluating arbitrary Excel formulas). Conditions that could never occur in an Excel spreadsheet should result in runtime exceptions. Care should be taken to not translate any POI internal error into an Excel evaluation error code.","version":0},{"id":"t_aeac69afe12f41cb9f952cbf046bccb2","oldText":"#REF! - Illegal or deleted cell reference","tlText":"#参考！- 非法或已删除的单元格引用","version":0},{"id":"t_04e0a1d04e504e26a6452b3c5c3a8ade","oldText":"#VALUE! - Wrong type of operand","tlText":"#价值！- 操作数类型错误","version":0},{"id":"t_79021134401641c8a444766b58124723","oldText":"#NUM! - Value range overflow","tlText":"#NUM！- 值范围溢出","version":0},{"id":"t_1669e854deaa45c1a2e1435a7d5ea3d8","oldText":"#VALUE! - Wrong type of operand","tlText":"#价值！- 操作数类型错误","version":0},{"id":"t_06ac5fdb68644fefbd7d8c86715129d3","oldText":"#REF! - Illegal or deleted cell reference","tlText":"#参考！- 非法或已删除的单元格引用","version":0},{"id":"t_ff880a58a5e14b6bab071fbc79dae2a0","oldText":"#NUM! - Value range overflow","tlText":"#NUM！- 值范围溢出","version":0}]