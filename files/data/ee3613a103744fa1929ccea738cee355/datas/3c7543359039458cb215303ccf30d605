[{"id":"t_69a765a864df446696c734a15b56dce8","oldText":"Title: Record Input Stream Description: Wraps a stream and provides helper methods for the construction of records.","tlText":"标题：记录输入流描述：包装流并提供用于构建记录的帮助器方法。","version":0},{"id":"t_3c197debb9e4431c8b0e8fa783404066","oldText":"For use in BiffViewer which may construct Records that don\u0027t completely read all available data.","tlText":"用于BiffViewer中，它可能会构建不完全读取所有可用数据的记录。","version":0},{"id":"t_6d3ef0773ecc4862b92239e2a90de3ab","oldText":"Maximum size of a single record (minus the 4 byte header) without a continue","tlText":"不带继续的单个记录的最大大小（减去4字节头）","version":0},{"id":"t_39cca4f678964c8490b636c39812e75e","oldText":"Note - this method is expected to be called only when completed reading the current BIFF record.","tlText":"注意-预计只有在完成读取当前BIFF记录时才会调用此方法。","version":0},{"id":"t_8cc076fe78854692b9db3f42c0db3391","oldText":"Mark the stream position - experimental function","tlText":"标记溪流位置-实验功能","version":0},{"id":"t_9151ae2859554493ad91354ed0561dd9","oldText":"Moves to the next record in the stream.","tlText":"移至流中的下一条记录。","version":0},{"id":"t_cf10d496d7274777bad1efb23ace0540","oldText":"Deprecated. POI 2.0 Best to write a input stream that wraps this one where there is special sub record that may overlap continue records.","tlText":"已废弃。POI 2.0最好编写一个包含此输入流的输入流，其中存在可能与连续记录重叠的特殊子记录。","version":0},{"id":"t_3946475d9e1247199a8972990817e994","oldText":"Reads an 8 bit, signed value","tlText":"读取8位有符号值","version":0},{"id":"t_4770d9a4124a4a7a81a0aaa640c2d641","oldText":"Reads a 32 bit, signed value","tlText":"读取32位有符号值","version":0},{"id":"t_efaec4fa63b5439ea0f112696bf00784","oldText":"Reads a 64 bit, signed value","tlText":"读取64位有符号值","version":0},{"id":"t_5d61feb97efe40cd8ac4c82d3392b0fc","oldText":"Usually acts the same as LittleEndianInput.readFully(byte[], int, int), but for an encrypted stream the raw (unencrypted) data is filled","tlText":"通常作用与LittleEndianInvestment.readFully（byte[]，int，int）相同，但对于加密流，原始（未加密）数据将被填充","version":0},{"id":"t_93118dd5e30145a5b6e379f10ed7a6c2","oldText":"Returns the remaining bytes for the current record.","tlText":"返回当前记录的剩余字节。","version":0},{"id":"t_6c2e30cb30194a4f9558202cf9cfe808","oldText":"Reads a 16 bit, signed value","tlText":"读取16位有符号值","version":0},{"id":"t_d61212c220e94414a2f9d188b7be924e","oldText":"Reads an 8 bit, unsigned value","tlText":"读取8位无符号值","version":0},{"id":"t_f48144ff94064882900f7d07e06d5595","oldText":"given a byte array of 16-bit unicode characters, compress to 8-bit and return a string { 0x16, 0x00 } -0x16","tlText":"给定一个由16位Unicode字符组成的字节数组，压缩为8位并返回字符串{0x 16，0x 00}-0x 16","version":0},{"id":"t_308beebc81b842969b66e0fd56f5d25a","oldText":"Reads a 16 bit, unsigned value.","tlText":"读取16位无符号值。","version":0},{"id":"t_ca946918859446faa331fdc0fdf9483d","oldText":"The remaining number of bytes in the current record.","tlText":"当前记录中的剩余字节数。","version":0},{"id":"t_54728ec2e7aa4f03b855f4b3c6e77785","oldText":"Resets the stream position to the previously marked position.","tlText":"将流位置重置为之前标记的位置。","version":0},{"id":"t_8a75928bb305430aa126fad6d514e354","oldText":"Maximum size of a single record (minus the 4 byte header) without a continue","tlText":"不带继续的单个记录的最大大小（减去4字节头）","version":0},{"id":"t_b666a16dc84b48bb9e363daf8fe374bd","oldText":"RecordFormatException","tlText":"记录异常","version":0},{"id":"t_7d12b3f757ea49719faafd910f56635e","oldText":"RecordFormatException","tlText":"记录异常","version":0},{"id":"t_7be3ad92b4034a4d8935d42097619f41","oldText":"available in interface LittleEndianInput","tlText":"可在LittleEndianConnect界面中使用","version":0},{"id":"t_8f38f38ad8a94754938322e57d0e2c38","oldText":"the number of bytes available in the current BIFF record","tlText":"当前BIFF记录中可用的字节数","version":0},{"id":"t_57a6dc86ad824143ac224338ff2b2d30","oldText":"Note - this method is expected to be called only when completed reading the current BIFF record.","tlText":"注意-预计只有在完成读取当前BIFF记录时才会调用此方法。","version":0},{"id":"t_f38c6674e29f424c8aba3e9fedd82a6f","oldText":"true, if there\u0027s another record in the stream","tlText":"如果流中有另一条记录，则为真","version":0},{"id":"t_84faf2a7a18b472993653bb0da9733a0","oldText":"RecordInputStream.LeftoverDataException - if this method is called before reaching the end of the current record.","tlText":"RecordInputStream. LeftoverDataResponse-如果在到达当前记录的结尾之前调用了此方法。","version":0},{"id":"t_cce32797234c4742886870d0c046e841","oldText":"Moves to the next record in the stream. Note: The auto continue flag is reset to true","tlText":"移至流中的下一条记录。注意：自动继续标志重置为true","version":0},{"id":"t_a97e1ecf2041484aaff3f4f00ef21003","oldText":"RecordFormatException","tlText":"记录异常","version":0},{"id":"t_4777cd37d9d944ac9076f0d43ec467a4","oldText":"Reads an 8 bit, signed value","tlText":"读取8位有符号值","version":0},{"id":"t_f4b543ca97c74cba882fc45ba6261038","oldText":"readByte in interface LittleEndianInput","tlText":"LittleEndianConnect接口中的读取字节","version":0},{"id":"t_874b924d4ddd449cb382db19cc146297","oldText":"Reads a 16 bit, signed value","tlText":"读取16位有符号值","version":0},{"id":"t_376feb10ae43453d80fd1daf65d2fbb2","oldText":"readShort in interface LittleEndianInput","tlText":"在界面中读取Short LittleEndianInvestment","version":0},{"id":"t_84aa4c24fae4463981b40591233c2e83","oldText":"Reads a 32 bit, signed value","tlText":"读取32位有符号值","version":0},{"id":"t_ab2384c97a3e424484d9d2fd9845bd05","oldText":"readInt in interface LittleEndianInput","tlText":"在界面LittleEndianInvestment中读取Int","version":0},{"id":"t_0a707b33b54d4af0ac6bb22b146015fd","oldText":"Reads a 64 bit, signed value","tlText":"读取64位有符号值","version":0},{"id":"t_71f37beff5eb4cb1b9df672a6ef7dac7","oldText":"readLong in interface LittleEndianInput","tlText":"在界面中读长LittleEndianInvestment","version":0},{"id":"t_78730431213b42d290cec4a785e29fe8","oldText":"Reads an 8 bit, unsigned value","tlText":"读取8位无符号值","version":0},{"id":"t_1ff03ab72a3d4b22a9a7dc4a22b19f0d","oldText":"readUByte in interface LittleEndianInput","tlText":"在接口LittleEndianInvestment中读取UByte","version":0},{"id":"t_fe3bc824553d40f1a8bb50df335d5b11","oldText":"Reads a 16 bit, unsigned value.","tlText":"读取16位无符号值。","version":0},{"id":"t_d118619c9230447b90ed392482867556","oldText":"readUShort in interface LittleEndianInput","tlText":"readU接口中的短路LittleEndianInput","version":0},{"id":"t_66bb8af8b844489b85a4666f919705f6","oldText":"readDouble in interface LittleEndianInput","tlText":"在界面LittleEndianInvestment中读取Double","version":0},{"id":"t_7ede39c32cd04b728f66552260866c11","oldText":"Usually acts the same as LittleEndianInput.readFully(byte[], int, int), but for an encrypted stream the raw (unencrypted) data is filled","tlText":"通常作用与LittleEndianInvestment.readFully（byte[]，int，int）相同，但对于加密流，原始（未加密）数据将被填充","version":0},{"id":"t_3426326917d94236b922cca26680c43e","oldText":"readPlain in interface LittleEndianInput","tlText":"readPlain在接口LittleEndianInput中","version":0},{"id":"t_6b0f86516fce43829d54fb8ff74f0c68","oldText":"buf - the byte array to receive the bytes","tlText":"buf -接收字节的字节数组","version":0},{"id":"t_1b1a1cee6e884a788fdd2f8ae8a8afc1","oldText":"off - the start offset into the byte array","tlText":"off -字节数组的开始偏差","version":0},{"id":"t_53afdc150ada4ef2a2e7b2b562192578","oldText":"len - the amount of bytes to fill","tlText":"len -要填充的字节量","version":0},{"id":"t_8ca1f883ae784e9194cfb1f58d7fe55a","oldText":"readFully in interface LittleEndianInput","tlText":"在界面LittleEndianInvestment中完全阅读","version":0},{"id":"t_69d896a69bed4dfa874e7038604ad1b1","oldText":"readFully in interface LittleEndianInput","tlText":"在界面LittleEndianInvestment中完全阅读","version":0},{"id":"t_7915af3ce37440d4924728ed37eed35e","oldText":"given a byte array of 16-bit unicode characters, compress to 8-bit and return a string { 0x16, 0x00 } -0x16","tlText":"给定一个由16位Unicode字符组成的字节数组，压缩为8位并返回字符串{0x 16，0x 00}-0x 16","version":0},{"id":"t_2d73368e73e441759b13f27812782f67","oldText":"requestedLength - the length of the final string","tlText":"请求长度-最终字符串的长度","version":0},{"id":"t_2bcd15e502af431893697a9c3e95c325","oldText":"the converted string","tlText":"转换后的字符串","version":0},{"id":"t_47b9f90981b941beb7f6a3d205749452","oldText":"java.lang.IllegalArgumentException - if len is too large (i.e., there is not enough data in string to create a String of that length)","tlText":"Java.lang. IllegalArgumentExcept-如果len太大（即，字符串中没有足够的数据来创建该长度的字符串）","version":0},{"id":"t_c49bf679d92448978c300ad50b328de9","oldText":"Returns the remaining bytes for the current record.","tlText":"返回当前记录的剩余字节。","version":0},{"id":"t_df0ad7d633ce4415a0120687abf97493","oldText":"The remaining bytes of the current record.","tlText":"当前记录的剩余字节。","version":0},{"id":"t_b06236e218924b3baeaf39da69b97e11","oldText":"Reads all byte data for the current record, including any that overlaps into any following continue records.","tlText":"读取当前记录的所有字节数据，包括任何与后续连续记录重叠的数据。","version":0},{"id":"t_1ac72e470c344d0db1b5813dd6b9937d","oldText":"all byte data for the current record","tlText":"当前记录的所有字节数据","version":0},{"id":"t_b6492866f686411789dbe9d5960eedf3","oldText":"The remaining number of bytes in the current record.","tlText":"当前记录中的剩余字节数。","version":0},{"id":"t_5fee6459577f4420bc4926b6aec726de","oldText":"The number of bytes remaining in the current record","tlText":"当前记录中剩余的字节数","version":0},{"id":"t_ef1d4fd5506d45799600b655dcf6d0ce","oldText":"sid of next record. Can be called after hasNextRecord()","tlText":"下一记录的sid。可以在hasNextRecord（）之后调用","version":0},{"id":"t_d7c955a75afa400e933d1616205d4a6c","oldText":"Mark the stream position - experimental function","tlText":"标记溪流位置-实验功能","version":0},{"id":"t_d8f2a5f6dcc14418aadb44cf65435d9f","oldText":"readlimit - the read ahead limit","tlText":"readlimit -预读限制","version":0},{"id":"t_643e10b6a3404105b3f10fe4e2dfba74","oldText":"Resets the stream position to the previously marked position. Experimental function - this only works, when nextRecord() wasn\u0027t called in the meantime.","tlText":"将流位置重置为之前标记的位置。实验函数-这仅在同时没有调用nextRecord（）时起作用。","version":0},{"id":"t_4ff187ebff114ce08a6cd1410ad98de5","oldText":"java.io.IOException - if marking is not supported","tlText":"java.io. IOResponse-如果不支持标记","version":0}]