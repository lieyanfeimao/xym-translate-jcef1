[{"id":"t_6866208e03824ccf8480c82e20a26273","oldText":"Calculate checksum on input data","tlText":"计算输入数据的检查和","version":0},{"id":"t_c73d50477e824bf39d246a7cdff2b765","oldText":"Calculate checksum on all the data read from input stream.","tlText":"计算从输入流读取的所有数据的检查和。","version":0},{"id":"t_99b68a1af8c347bbb6392cf1ad0cfc73","oldText":"Quietly (no exceptions) close Closable resource.","tlText":"悄然（无例外）关闭可关闭资源。","version":0},{"id":"t_3f2e206e52344d098cbe86b8d7375810","oldText":"Copy the contents of the stream to a new file.","tlText":"将流的内容复制到新文件中。","version":0},{"id":"t_7f56b4b6458c4c709fbee40ea384ebd1","oldText":"Copies all the data from the given InputStream to the OutputStream.","tlText":"将所有数据从给定InputStream复制到OutputStream。","version":0},{"id":"t_f2f9ff45452449d2823641809553c53d","oldText":"Copies all the data from the given InputStream to the OutputStream.","tlText":"将所有数据从给定InputStream复制到OutputStream。","version":0},{"id":"t_0d73562e5a1144818af1589bb9069dfc","oldText":"Peeks at the first 8 bytes of the stream.","tlText":"查看流的前8个字节。","version":0},{"id":"t_1f50aed31f4c43bbad693c8a7ec52a16","oldText":"Peeks at the first N bytes of the stream.","tlText":"查看流的前N个字节。","version":0},{"id":"t_fcd571256c244a4a962f3574b05227f4","oldText":"Simple utility function to check that you haven\u0027t hit EOF when reading a byte.","tlText":"简单的实用函数可以检查您在读取字节时是否没有按下RST键。","version":0},{"id":"t_14b024820ecc4e1fb04bb37087c7ddf3","oldText":"Helper method, just calls readFully(in, b, 0, b.length)","tlText":"Helper方法，仅调用readFully（in，b，0，b. size）","version":0},{"id":"t_166fd81514fb4078bc73c91981e969d4","oldText":"Same as the normal InputStream.read(byte[], int, int), but tries to ensure that the entire len number of bytes is read.","tlText":"与正常的InputStream.read（byte[]，int，int）相同，但试图确保读取整个len字节数。","version":0},{"id":"t_0c0dca52f2234554b969c1e0b6f9b89c","oldText":"Same as the normal channel.read(b), but tries to ensure that the buffer is filled completely if possible, i.e.","tlText":"与正常的channel.read（b）相同，但尝试确保缓冲区在可能的情况下完全填充，即","version":0},{"id":"t_18e49d5bc08d43429536dc07d62c6d55","oldText":"If this value is set to \u003e 0, safelyAllocate(long, int) will ignore the maximum record length parameter.","tlText":"如果此值设置为\u003e 0，safelyAllocate（long，int）将忽略最大记录长度参数。","version":0},{"id":"t_69b05b7327f744158486f87a7aa514ba","oldText":"Skips bytes from an input byte stream.","tlText":"跳过输入字节流中的字节。","version":0},{"id":"t_e76581405acf4c0bbcfea996df3306e2","oldText":"Returns an array (that shouldn\u0027t be written to!) of the ByteBuffer.","tlText":"返回一个数组（不应该写入！）字节缓冲区的。","version":0},{"id":"t_a7864535e028462c8fd0755aeb702dc5","oldText":"Reads all the data from the input stream, and returns the bytes read.","tlText":"从输入流读取所有数据，并返回读取的字节。","version":0},{"id":"t_b42b66a72b8e49d69b126281ab7c2ba7","oldText":"Reads up to length bytes from the input stream, and returns the bytes read.","tlText":"从输入流中读取最长字节，并返回读取的字节。","version":0},{"id":"t_9f558925e0c84bdb9362fed9779b6223","oldText":"Reads up to length bytes from the input stream, and returns the bytes read.","tlText":"从输入流中读取最长字节，并返回读取的字节。","version":0},{"id":"t_60b7b2975a7d4d2aa8e5e5da6a42b3c2","oldText":"If this value is set to \u003e 0, safelyAllocate(long, int) will ignore the maximum record length parameter. This is designed to allow users to bypass the hard-coded maximum record lengths if they are willing to accept the risk of allocating memory up to the size specified. It also allows to impose a lower limit than used for very memory constrained systems. Note: This is an per-allocation limit and does not allow to limit overall sum of allocations! Use -1 for using the limits specified per record-type.","tlText":"如果此值设置为\u003e 0，safelyAllocate（long，int）将忽略最大记录长度参数。这是为了允许用户在愿意接受分配高达指定大小的内存的风险时绕过硬编码的最大记录长度。它还允许施加比内存限制严重的系统更低的限制。注意：这是每次分配的限制，不允许限制分配的总额！使用-1表示使用每个记录类型指定的限制。","version":0},{"id":"t_d68a3a2dba9a4bcd9d1a506827a3a108","oldText":"maxOverride - The maximum number of bytes that should be possible to be allocated in one step.","tlText":"MaxSYS-一步中可以分配的最大字节数。","version":0},{"id":"t_526d6a884b7648c9a7c913c99014e2ed","oldText":"Peeks at the first 8 bytes of the stream. Returns those bytes, but with the stream unaffected. Requires a stream that supports mark/reset, or a PushbackInputStream. If the stream has \u003e0 but \u003c8 bytes, remaining bytes will be zero.","tlText":"查看流的前8个字节。返回这些字节，但流不受影响。需要支持标记/重置的流或PushbackInputStream。如果流的字节数大于0但小于8，则剩余字节数为零。","version":0},{"id":"t_642267c065644598830a055ab4e6121d","oldText":"EmptyFileException - if the stream is empty","tlText":"EmptyFile异常-如果流为空","version":0},{"id":"t_71e0c19d651f4d7687a9b8e216f8859d","oldText":"java.io.IOException","tlText":"java.io.IOException","version":0},{"id":"t_69cffd4f3d1b41c0af0b1741d2a0e2f7","oldText":"Peeks at the first N bytes of the stream. Returns those bytes, but with the stream unaffected. Requires a stream that supports mark/reset, or a PushbackInputStream. If the stream has \u003e0 but \u003cN bytes, remaining bytes will be zero.","tlText":"查看流的前N个字节。返回这些字节，但流不受影响。需要支持标记/重置的流或PushbackInputStream。如果流的字节\u003e0但\u003cN，则剩余字节将为零。","version":0},{"id":"t_ab3e9a5623b3462295bce37de5172242","oldText":"EmptyFileException - if the stream is empty","tlText":"EmptyFile异常-如果流为空","version":0},{"id":"t_23ce32001965453f8006cf2463b76d8a","oldText":"java.io.IOException","tlText":"java.io.IOException","version":0},{"id":"t_6fb55a9b2d1b4fd6849ae9417740b971","oldText":"Reads all the data from the input stream, and returns the bytes read.","tlText":"从输入流读取所有数据，并返回读取的字节。","version":0},{"id":"t_5a7e797a48c446089a3e1cf722ce8fd0","oldText":"stream - The byte stream of data to read.","tlText":"stream -要读取的数据的字节流。","version":0},{"id":"t_c280fb3cc3cb4353b9ac2bb5dc46b9de","oldText":"A byte array with the read bytes.","tlText":"包含读取字节的字节数组。","version":0},{"id":"t_564119466ccb4a3eb437ae52a4bb1c78","oldText":"java.io.IOException - If reading data fails or EOF is encountered too early for the given length.","tlText":"java.io. IOResponse-如果读取数据失败或对于给定长度过早遇到超时。","version":0},{"id":"t_5e4270415d6a4020b72e8f02b54f1320","oldText":"Reads up to length bytes from the input stream, and returns the bytes read.","tlText":"从输入流中读取最长字节，并返回读取的字节。","version":0},{"id":"t_ff297f4156404d3c8dd67088940f0736","oldText":"stream - The byte stream of data to read.","tlText":"stream -要读取的数据的字节流。","version":0},{"id":"t_798e5d1aaf254ab8b687eb3384319a87","oldText":"length - The maximum length to read, use Integer.MAX_VALUE to read the stream until EOF.","tlText":"长度-要读取的最大长度，使用RST.MAX_UTE读取流直到RST。","version":0},{"id":"t_c68b7802802f4c73b035c129a4cfd51f","oldText":"A byte array with the read bytes.","tlText":"包含读取字节的字节数组。","version":0},{"id":"t_f13c00e5b227442faddbf845b50b6fc2","oldText":"java.io.IOException - If reading data fails or EOF is encountered too early for the given length.","tlText":"java.io. IOResponse-如果读取数据失败或对于给定长度过早遇到超时。","version":0},{"id":"t_d7966ae0ccc843ec8e56210c7b526793","oldText":"Reads up to length bytes from the input stream, and returns the bytes read.","tlText":"从输入流中读取最长字节，并返回读取的字节。","version":0},{"id":"t_44b776ce151f498e8ed2623b18c173e1","oldText":"stream - The byte stream of data to read.","tlText":"stream -要读取的数据的字节流。","version":0},{"id":"t_5598d22b469f4228bdb756c45411290b","oldText":"length - The maximum length to read, use Integer.MAX_VALUE to read the stream until EOF","tlText":"长度-要读取的最大长度，使用RST.MAX_UTE读取流，直到RST","version":0},{"id":"t_8c60a32475a340c1b666fd3f22dd7066","oldText":"maxLength - if the input is equal to/longer than maxLength bytes, then throw an IOException complaining about the length. use Integer.MAX_VALUE to disable the check","tlText":"MaxSize-如果输入等于/长于MaxSize字节，则引发一个IOResponse，抱怨长度。使用RST.MAX_UTE禁用检查","version":0},{"id":"t_74155d8f2638456a982e045a32e3736b","oldText":"A byte array with the read bytes.","tlText":"包含读取字节的字节数组。","version":0},{"id":"t_6dbd044b9fc748cab8dbcecd9abb13ec","oldText":"java.io.IOException - If reading data fails or EOF is encountered too early for the given length.","tlText":"java.io. IOResponse-如果读取数据失败或对于给定长度过早遇到超时。","version":0},{"id":"t_4c368a11e208466094f146af2291afb2","oldText":"Returns an array (that shouldn\u0027t be written to!) of the ByteBuffer. Will be of the requested length, or possibly longer if that\u0027s easier.","tlText":"返回一个数组（不应该写入！）字节缓冲区的。将是所需的长度，如果更容易的话，可能会更长。","version":0},{"id":"t_a229a65a68f240f58f3f6e4b577d9762","oldText":"Helper method, just calls readFully(in, b, 0, b.length)","tlText":"Helper方法，仅调用readFully（in，b，0，b. size）","version":0},{"id":"t_413461231b084c90a5f456283dcd43e6","oldText":"java.io.IOException","tlText":"java.io.IOException","version":0},{"id":"t_42b701f0e20d4e9aaa47c7d750bc0adb","oldText":"Same as the normal InputStream.read(byte[], int, int), but tries to ensure that the entire len number of bytes is read. If the end of file is reached before any bytes are read, returns -1. If the end of the file is reached after some bytes are read, returns the number of bytes read. If the end of the file isn\u0027t reached before len bytes have been read, will return len bytes.","tlText":"与正常的InputStream.read（byte[]，int，int）相同，但试图确保读取整个len字节数。如果在读取任何字节之前到达文件结尾，则返回-1。如果在读取一些字节后到达文件的结尾，则返回读取的字节数。如果在读取len字节之前尚未到达文件的结尾，则将返回len字节。","version":0},{"id":"t_46a30c2f1afb4b01bfd62d6d20d79255","oldText":"in - the stream from which the data is read.","tlText":"in -读取数据的流。","version":0},{"id":"t_ccb4c087e1f84588abd368f6362274c8","oldText":"b - the buffer into which the data is read.","tlText":"b -数据被读取的缓冲区。","version":0},{"id":"t_2fc1d463ac9d4a248bfb145420be1873","oldText":"off - the start offset in array b at which the data is written.","tlText":"off -数组b中写入数据的起始偏移量。","version":0},{"id":"t_78f888ddd16c4c48808b650d570b47d0","oldText":"len - the maximum number of bytes to read.","tlText":"len -要读取的最大字节数。","version":0},{"id":"t_33fe7d2256474fbfacbc80929472f280","oldText":"java.io.IOException","tlText":"java.io.IOException","version":0},{"id":"t_dd5a8278f35e4bc9a1d049e3446a8a65","oldText":"Same as the normal channel.read(b), but tries to ensure that the buffer is filled completely if possible, i.e. b.remaining() returns 0. If the end of file is reached before any bytes are read, returns -1. If the end of the file is reached after some bytes are read, returns the number of bytes read. If the end of the file isn\u0027t reached before the buffer has no more remaining capacity, will return the number of bytes that were read.","tlText":"与正常的channel.read（b）相同，但如果可能的话，会尝试确保缓冲区完全填充，即b. resting（）返回0。如果在读取任何字节之前到达文件结尾，则返回-1。如果在读取一些字节后到达文件的结尾，则返回读取的字节数。如果在缓冲区没有剩余容量之前尚未到达文件的末尾，则将返回已读取的字节数。","version":0},{"id":"t_ddc3e598405e4b83ac72c39f3685325e","oldText":"java.io.IOException","tlText":"java.io.IOException","version":0},{"id":"t_56203e45d17c4ceebd93caaeef68d3e1","oldText":"Copies all the data from the given InputStream to the OutputStream. It leaves both streams open, so you will still need to close them once done.","tlText":"将所有数据从给定InputStream复制到OutputStream。它会使两个流保持打开状态，因此完成后您仍然需要关闭它们。","version":0},{"id":"t_a87a0005974a4a41a5bb0abc0bbbda5f","oldText":"inp - The InputStream which provides the data","tlText":"inp -提供数据的InputStream","version":0},{"id":"t_5cd6806ad2554813be727f05ec4ea0f3","oldText":"out - The OutputStream to write the data to","tlText":"out -要写入数据的OutputStream","version":0},{"id":"t_c10a7b6499004887955a197dd7115db7","oldText":"the amount of bytes copied","tlText":"复制的字节量","version":0},{"id":"t_007c7e858c824189b4780478782df0b7","oldText":"java.io.IOException - If copying the data fails.","tlText":"java.io. IOResponse-如果复制数据失败。","version":0},{"id":"t_62389bf710d5478b957ab36a7cf6f615","oldText":"Copies all the data from the given InputStream to the OutputStream. It leaves both streams open, so you will still need to close them once done.","tlText":"将所有数据从给定InputStream复制到OutputStream。它会使两个流保持打开状态，因此完成后您仍然需要关闭它们。","version":0},{"id":"t_daae7cc407c143cbaf7458d60a787d70","oldText":"inp - The InputStream which provides the data","tlText":"inp -提供数据的InputStream","version":0},{"id":"t_665a9526b44c4c64aaf713a2a47628af","oldText":"out - The OutputStream to write the data to","tlText":"out -要写入数据的OutputStream","version":0},{"id":"t_a81d13a1e6874530b21582a64233cad2","oldText":"limit - limit the copied bytes - use -1 for no limit","tlText":"limit -限制复制的字节-使用-1表示无限制","version":0},{"id":"t_4398072857034cb0a89674f6fe4dbaf5","oldText":"the amount of bytes copied","tlText":"复制的字节量","version":0},{"id":"t_88eaf76651c74336a0207bcd7ecc789c","oldText":"java.io.IOException - If copying the data fails.","tlText":"java.io. IOResponse-如果复制数据失败。","version":0},{"id":"t_7965ad1eabcb4c1a9281e1600fbc1a0e","oldText":"Copy the contents of the stream to a new file.","tlText":"将流的内容复制到新文件中。","version":0},{"id":"t_4b67d783a83543d591760fd28eba4f5e","oldText":"srcStream - The InputStream which provides the data","tlText":"srcStream -提供数据的InputStream","version":0},{"id":"t_b2db716af45a4a0685e0d2b509755f6e","oldText":"destFile - The file where the data should be stored","tlText":"DestFile -应存储数据的文件","version":0},{"id":"t_c6a53c9b1b9c4178b7a28784b5b29e4f","oldText":"the amount of bytes copied","tlText":"复制的字节量","version":0},{"id":"t_9ea75318523242859bba39ed7a22ec97","oldText":"java.io.IOException - If the target directory does not exist and cannot be created or if copying the data fails.","tlText":"IOException -如果目标目录不存在并且无法创建，或者复制数据失败。","version":0},{"id":"t_24ede775af6e43f3bccff51260fae4db","oldText":"Calculate checksum on input data","tlText":"计算输入数据的检查和","version":0},{"id":"t_870c3c16bf9948e188581c8135609752","oldText":"Calculate checksum on all the data read from input stream. This should be more efficient than the equivalent code IOUtils.calculateChecksum(IOUtils.toByteArray(stream))","tlText":"计算从输入流读取的所有数据的检查和。这应该比等效代码IOUtils.calculateChecksum（IOUtils.toByteArray（stream））更有效","version":0},{"id":"t_977affa2cb6f4bc6a235dd550429a7a3","oldText":"java.io.IOException","tlText":"java.io.IOException","version":0},{"id":"t_a50c1918fd2c4216be64c24e720d40ee","oldText":"Quietly (no exceptions) close Closable resource. In case of error it will be printed to IOUtils class logger.","tlText":"悄然（无例外）关闭可关闭资源。如果出现错误，它将被打印到IOUtils类记录器。","version":0},{"id":"t_978156327ef244c0b19893c5d71ed2b2","oldText":"closeable - resource to close","tlText":"可关闭-要关闭的资源","version":0},{"id":"t_7ec77df91edb4f6081530fb09aca947a","oldText":"Skips bytes from an input byte stream. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case for skip() implementations in subclasses of InputStream. Note that the implementation uses InputStream.read(byte[], int, int) rather than delegating to InputStream.skip(long). This means that the method may be considerably less efficient than using the actual skip implementation, this is done to guarantee that the correct number of bytes are skipped. This mimics POI\u0027s readFully(InputStream, byte[]). If the end of file is reached before any bytes are read, returns -1. If the end of the file is reached after some bytes are read, returns the number of bytes read. If the end of the file isn\u0027t reached before len bytes have been read, will return len bytes. Copied nearly verbatim from commons-io 41a3e9c","tlText":"跳过输入字节流中的字节。此实现保证它在放弃之前将读取尽可能多的字节;对于InputStream的子类中的skip（）实现来说，情况可能并不总是如此。请注意，该实现使用InputStream.read（byte[]，int，int），而不是委托给InputStream.skip（long）。这意味着该方法可能比使用实际跳过实现的效率低得多，这样做是为了保证跳过正确数量的字节。这模仿了DOE的readFully（InputStream，byte[]）。如果在读取任何字节之前到达文件结尾，则返回-1。如果在读取一些字节后到达文件的结尾，则返回读取的字节数。如果在读取len字节之前尚未到达文件的结尾，则将返回len字节。几乎逐字复制自commons-io 41 a3 e9 c","version":0},{"id":"t_2b3a7af12c454906be78331fec288fe5","oldText":"input - byte stream to skip","tlText":"输入-要跳过的字节流","version":0},{"id":"t_5f24dff2e27445c1a673d636a13f8069","oldText":"toSkip - number of bytes to skip.","tlText":"toSkip -要跳过的字节数。","version":0},{"id":"t_eac08cc68a974c23bbef3539c2ccbc77","oldText":"number of bytes actually skipped.","tlText":"实际跳过的字节数。","version":0},{"id":"t_be0e32a5c6f64eb6a715817bfde46542","oldText":"java.io.IOException - if there is a problem reading the file","tlText":"java.io. IOResponse-如果读取文件时出现问题","version":0},{"id":"t_9da16b1f457b44cca3f55703da332070","oldText":"java.lang.IllegalArgumentException - if toSkip is negative","tlText":"Java.lang. IllegalArgumentExcept-如果toSkip为负","version":0},{"id":"t_222de7c36b384d24be6e71942dfde1f9","oldText":"Simple utility function to check that you haven\u0027t hit EOF when reading a byte.","tlText":"简单的实用函数可以检查您在读取字节时是否没有按下RST键。","version":0},{"id":"t_7ca89424abae4296ae09d501a9f8758c","oldText":"is - inputstream to read","tlText":"is -输入流要阅读","version":0},{"id":"t_e30bbf36fd814fad961bd0a6feb3d108","oldText":"byte read, unless","tlText":"字节读取，除非","version":0},{"id":"t_37d97954532e40e5a7d33486d644fcc2","oldText":"java.io.IOException - on IOException or EOF if -1 is read","tlText":"java.io. IOResponse-如果读取-1，则出现IOResponse或RST","version":0}]