[{"id":"t_37d8152ad8604f3d9c06ae2cdd6d85c1","oldText":"Collection of string handling utilities","tlText":"字符串处理实用程序的集合","version":0},{"id":"t_47c6d5326927443daddf64f678e1c44a","oldText":"Count number of occurrences of needle in haystack Has same signature as org.apache.commons.lang3.StringUtils#countMatches","tlText":"统计大海捞针的出现次数与org.apache. commons.lang3.StringUtils#countMatches相同签名","version":0},{"id":"t_a06300aee4fc46a8a63a3a9a2ad7feb1","oldText":"Tests if the string ends with the specified suffix, ignoring case consideration.","tlText":"测试字符串是否以指定的后缀结束，忽略大小写考虑。","version":0},{"id":"t_d35ce6a7d3a1433aadea50c5bec0bed6","oldText":"Read 8 bit data (in ISO-8859-1 codepage) into a (unicode) Java String and return.","tlText":"将8位数据（在ISO-8859-1代码页中）读取到（unicode）Java字符串中并返回。","version":0},{"id":"t_ff2ffac50c674683b8d7723799b21b10","oldText":"Given a byte array of 16-bit unicode characters in little endian format (most important byte last), return a Java String representation of it.","tlText":"给定一个由小字节序格式的16位Unicode字符组成的字节数组（最重要的字节最后），返回它的Java字符串表示。","version":0},{"id":"t_eebae617b21f4542aac414e6551b596f","oldText":"Given a byte array of 16-bit unicode characters in Little Endian format (most important byte last), return a Java String representation of it.","tlText":"给定Little Endian格式的16位unicode字符的字节数组（最重要的字节最后），返回其Java字符串表示。","version":0},{"id":"t_a8eea54023c54ee9924597ced101e06a","oldText":"Given a byte array of 16-bit unicode characters in Little Endian format (most important byte last), return a Java String representation of it.","tlText":"给定Little Endian格式的16位unicode字符的字节数组（最重要的字节最后），返回其Java字符串表示。","version":0},{"id":"t_815687ec91694c229ca4c4f7d9630d4a","oldText":"Convert String to 16-bit unicode characters in little endian format","tlText":"将字符串转换为little endian格式的16位unicode字符","version":0},{"id":"t_9deb7d1f5d3946be9884e8786ad5a265","oldText":"check the parameter has multibyte character","tlText":"检查参数是否有多字节字符","version":0},{"id":"t_a6420bdf808a4e7f8b85fd07d82d9bb8","oldText":"Some strings may contain encoded characters of the unicode private use area.","tlText":"某些字符串可能包含unicode专用区域的编码字符。","version":0},{"id":"t_806727cc3b3a4d33a853d71d41f3008b","oldText":"Takes a unicode (java) string, and returns it as 8 bit data (in ISO-8859-1 codepage).","tlText":"获取unicode（Java）字符串，并将其作为8位数据返回（在ISO-8859-1代码页中）。","version":0},{"id":"t_046b47fcc7bf49f2a747b946fa4c5eac","oldText":"Takes a unicode string, and returns it as little endian (most important byte last) bytes in the supplied byte array.","tlText":"获取unicode字符串，并将其作为提供的字节数组中的小endian（最重要的字节最后）字节返回。","version":0},{"id":"t_04208b741b21409ea148150a9e266992","oldText":"InputStream in is expected to contain: ushort nChars byte is16BitFlag byte[]/char[] characterData For this encoding, the is16BitFlag is always present even if nChars\u003d\u003d0.","tlText":"InputStream预计将包含：ushort nChars byte is 16 BitFlag byte[]/char[] charterData对于此编码，即使nChars\u003d\u003d0，is 16 BitFlag也始终存在。","version":0},{"id":"t_0ea65518d6474dd49051a10ebf0e8038","oldText":"InputStream in is expected to contain: byte is16BitFlag byte[]/char[] characterData For this encoding, the is16BitFlag is always present even if nChars\u003d\u003d0.","tlText":"InputStream预计包含：byte is 16 BitFlag byte[]/char[] charterData对于此编码，即使nChars\u003d\u003d0，is 16 BitFlag也始终存在。","version":0},{"id":"t_d74e7e27b66048a3a193fe95285e6ddc","oldText":"Tests if the string starts with the specified prefix, ignoring case consideration.","tlText":"测试字符串是否以指定的开头，忽略大小写考虑。","version":0},{"id":"t_a4bc9e301e7947e0aa5446c2f39467c0","oldText":"OutputStream out will get: ushort nChars byte is16BitFlag byte[]/char[] characterData For this encoding, the is16BitFlag is always present even if nChars\u003d\u003d0.","tlText":"OutputStream输出将获得：关闭nChars byte is 16 BitFlag byte[]/char[] charterData对于此编码，即使nChars\u003d\u003d0，is 16 BitFlag也始终存在。","version":0},{"id":"t_fc51cd6b3c84416da2dc2ec5a59c9f40","oldText":"OutputStream out will get: byte is16BitFlag byte[]/char[] characterData For this encoding, the is16BitFlag is always present even if nChars\u003d\u003d0.","tlText":"OutputStream输出将获得：byte is 16 BitFlag byte[]/char[] charterData对于此编码，即使nChars\u003d\u003d0，is 16 BitFlag也始终存在。","version":0},{"id":"t_99ee9c95e2134b28aa4da26a34105b52","oldText":"Given a byte array of 16-bit unicode characters in Little Endian format (most important byte last), return a Java String representation of it. { 0x16, 0x00 } -0x16","tlText":"给定Little Endian格式的16位unicode字符的字节数组（最重要的字节最后），返回其Java字符串表示。{0x 16，0x 00}-0x 16","version":0},{"id":"t_8d8b30b9fa894704ab1cc073ab532e0c","oldText":"string - the byte array to be converted","tlText":"字符串-要转换的字节数组","version":0},{"id":"t_8f8f59c83bcd4706ba58914d4b85aec4","oldText":"offset - the initial offset into the byte array. it is assumed that string[ offset ] and string[ offset + 1 ] contain the first 16-bit unicode character","tlText":"Offset -字节数组的初始偏差。假设字符串[lock]和字符串[lock + 1 ]包含第一个16位Unicode字符","version":0},{"id":"t_80f7d433e180465fbcb787338e6666cb","oldText":"len - the length of the final string","tlText":"len -最后一个字符串的长度","version":0},{"id":"t_a540249316e847f3b4b72fb6608b7e01","oldText":"the converted string, never null.","tlText":"转换后的字符串，绝不能为空。","version":0},{"id":"t_0d86fa31e1d745b2a4fc82c12a21ba56","oldText":"java.lang.ArrayIndexOutOfBoundsException - if offset is out of bounds for the byte array (i.e., is negative or is greater than or equal to string.length)","tlText":"java.lang. ArrayIndexOutOfBoundsResponse-如果字节数组的偏差超出界限（即，为负或大于或等于字符串.长度）","version":0},{"id":"t_546a98b13ca74d3bbb95fd4d30ff3554","oldText":"java.lang.IllegalArgumentException - if len is too large (i.e., there is not enough data in string to create a String of that length)","tlText":"Java.lang. IllegalArgumentExcept-如果len太大（即，字符串中没有足够的数据来创建该长度的字符串）","version":0},{"id":"t_f49018b760464ad8a8a939c2dcd0704c","oldText":"Given a byte array of 16-bit unicode characters in little endian format (most important byte last), return a Java String representation of it. { 0x16, 0x00 } -0x16","tlText":"给定一个16位unicode字符的字节数组（最重要的字节在最后），返回它的Java String表示形式。{0x 16，0x 00} -0x16","version":0},{"id":"t_4dfd4ce8903a484195c5738d9831b6da","oldText":"string - the byte array to be converted","tlText":"字符串-要转换的字节数组","version":0},{"id":"t_ab17f35526e1428385f45ab66076fdf4","oldText":"the converted string, never null","tlText":"转换后的字符串，从不为空","version":0},{"id":"t_be68ac98eb9743f4a364d2829053c285","oldText":"Convert String to 16-bit unicode characters in little endian format","tlText":"将字符串转换为little endian格式的16位unicode字符","version":0},{"id":"t_b507225421f441d4bb292a187b37e5d5","oldText":"string - the string","tlText":"字符串-字符串","version":0},{"id":"t_c34526b7040b4ade98eee7936e1d7c87","oldText":"the byte array of 16-bit unicode characters","tlText":"16位Unicode字符的字节数组","version":0},{"id":"t_dd0631fb8cbe4b8cb0da12e005484470","oldText":"Read 8 bit data (in ISO-8859-1 codepage) into a (unicode) Java String and return. (In Excel terms, read compressed 8 bit unicode as a string)","tlText":"将8位数据（在ISO-8859-1代码页中）读取到（unicode）Java字符串中并返回。(In Excel术语，将压缩的8位Unicode读取为字符串）","version":0},{"id":"t_0f57e87f58fe43f0be44ec35855b3be6","oldText":"string - byte array to read","tlText":"字符串-要读取的字节数组","version":0},{"id":"t_80d63ab80e3742bf8e697d8eb50df856","oldText":"offset - offset to read byte array","tlText":"odge-读取字节数组的偏置","version":0},{"id":"t_eaa82eaf862849dc8d0ecc13b18b4b90","oldText":"len - length to read byte array","tlText":"len -读取字节数组的长度","version":0},{"id":"t_6c46aa689c8748a3893eedd4e54f9c11","oldText":"String generated String instance by reading byte array","tlText":"字符串通过读取字节数组生成字符串实例","version":0},{"id":"t_dec2ae13bbb74d65bdc740f76c3430bb","oldText":"InputStream in is expected to contain: ushort nChars byte is16BitFlag byte[]/char[] characterData For this encoding, the is16BitFlag is always present even if nChars\u003d\u003d0. This structure is also known as a XLUnicodeString.","tlText":"InputStream预计将包含：ushort nChars byte is 16 BitFlag byte[]/char[] charterData对于此编码，即使nChars\u003d\u003d0，is 16 BitFlag也始终存在。此结构也称为XLUnicode字符串。","version":0},{"id":"t_0212b7a89808488daf31b683484ca840","oldText":"InputStream in is expected to contain: byte is16BitFlag byte[]/char[] characterData For this encoding, the is16BitFlag is always present even if nChars\u003d\u003d0. This method should be used when the nChars field is not stored as a ushort immediately before the is16BitFlag. Otherwise, readUnicodeString(LittleEndianInput) can be used.","tlText":"InputStream预计包含：byte is 16 BitFlag byte[]/char[] charterData对于此编码，即使nChars\u003d\u003d0，is 16 BitFlag也始终存在。当nChars字段没有存储为is 16 BitFlag之前的关闭时，应使用此方法。否则，可以使用readUnicode字符串（LittleEndianInvestment）。","version":0},{"id":"t_619eacc9ad66442da4f7c5860a3f5c31","oldText":"OutputStream out will get: ushort nChars byte is16BitFlag byte[]/char[] characterData For this encoding, the is16BitFlag is always present even if nChars\u003d\u003d0.","tlText":"OutputStream输出将获得：关闭nChars byte is 16 BitFlag byte[]/char[] charterData对于此编码，即使nChars\u003d\u003d0，is 16 BitFlag也始终存在。","version":0},{"id":"t_b379ee0c2a0940c48f246b51f64d2873","oldText":"OutputStream out will get: byte is16BitFlag byte[]/char[] characterData For this encoding, the is16BitFlag is always present even if nChars\u003d\u003d0. This method should be used when the nChars field is not stored as a ushort immediately before the is16BitFlag. Otherwise, writeUnicodeString(LittleEndianOutput, String) can be used.","tlText":"OutputStream输出将获得：byte is 16 BitFlag byte[]/char[] charterData对于此编码，即使nChars\u003d\u003d0，is 16 BitFlag也始终存在。当nChars字段没有存储为is 16 BitFlag之前的关闭时，应使用此方法。否则，可以使用writeUnicode字符串（LittleEndianExit，字符串）。","version":0},{"id":"t_5162ec702cd0410da3e3a490d44653d8","oldText":"the number of bytes that would be written by writeUnicodeString(LittleEndianOutput, String)","tlText":"writeUnicodeString（LittleEndianOutput，String）将写入的字节数","version":0},{"id":"t_fb7a60726f244b15be9dfb4620b26425","oldText":"Takes a unicode (java) string, and returns it as 8 bit data (in ISO-8859-1 codepage). (In Excel terms, write compressed 8 bit unicode)","tlText":"获取unicode（Java）字符串，并将其作为8位数据返回（在ISO-8859-1代码页中）。(In Excel术语，编写压缩8位Unicode）","version":0},{"id":"t_5de371367aa945b2a5d3c187f4e488c9","oldText":"input - the String containing the data to be written","tlText":"输入-包含要写入的数据的字符串","version":0},{"id":"t_d5a24219bf7042b0b3afb46b986e03ce","oldText":"output - the byte array to which the data is to be written","tlText":"输出-数据要写入的字节数组","version":0},{"id":"t_0ac1d485a88141a28b4a2ffad60dec48","oldText":"offset - an offset into the byte arrat at which the data is start when written","tlText":"Offset -写入数据时开始的字节arrat的偏差","version":0},{"id":"t_ed239d41cce44f43be7180da641b54cd","oldText":"Takes a unicode string, and returns it as little endian (most important byte last) bytes in the supplied byte array. (In Excel terms, write uncompressed unicode)","tlText":"获取unicode字符串，并将其作为提供的字节数组中的小endian（最重要的字节最后）字节返回。(In Excel术语，编写未压缩的Unicode）","version":0},{"id":"t_184e2d619f5a44738eb639e233f8be5f","oldText":"input - the String containing the unicode data to be written","tlText":"输入-包含要写入的unicode数据的字符串","version":0},{"id":"t_7ce02ba152bb4678920ca4cd78d50c2e","oldText":"output - the byte array to hold the uncompressed unicode, should be twice the length of the String","tlText":"输出-保存未压缩Unicode的字节数组，应该是字符串长度的两倍","version":0},{"id":"t_ca2cb79ab40d4c2e9a517b10ad30c012","oldText":"offset - the offset to start writing into the byte array","tlText":"Offset -开始写入字节数组的偏差","version":0},{"id":"t_106d95cd66e34add943b40b260381e1e","oldText":"the encoding we want to use, currently hardcoded to ISO-8859-1","tlText":"我们要使用的编码，目前硬编码为ISO-8859-1","version":0},{"id":"t_aafcd0c5f0234f559ad69f615574d3c4","oldText":"check the parameter has multibyte character","tlText":"检查参数是否有多字节字符","version":0},{"id":"t_5209ea2546664c54bf90c967ffd6ef69","oldText":"value - string to check","tlText":"值-要检查的字符串","version":0},{"id":"t_b67afcb7037b422fbf3c01813bb47397","oldText":"boolean result true:string has at least one multibyte character","tlText":"布尔结果true：字符串至少有一个多字节字符","version":0},{"id":"t_65bb9499972f405694fb2d06fe3dffe8","oldText":"Tests if the string starts with the specified prefix, ignoring case consideration.","tlText":"测试字符串是否以指定的开头，忽略大小写考虑。","version":0},{"id":"t_8b5b62e2808747f880ee183ff30e5c7c","oldText":"Tests if the string ends with the specified suffix, ignoring case consideration.","tlText":"测试字符串是否以指定的后缀结束，忽略大小写考虑。","version":0},{"id":"t_3c3ab621a3bf4dc5a5d03eeaa8991956","oldText":"Some strings may contain encoded characters of the unicode private use area. Currently the characters of the symbol fonts are mapped to the corresponding characters in the normal unicode range.","tlText":"某些字符串可能包含unicode专用区域的编码字符。目前符号字体的字符被映射到正常unicode范围中的相应字符。","version":0},{"id":"t_79e664939f0848f78fe8c09af25861bc","oldText":"string - the original string","tlText":"字符串-原始字符串","version":0},{"id":"t_42bc793b4f9140db96c41867e1daabea","oldText":"the string with mapped characters","tlText":"具有映射字符的字符串","version":0},{"id":"t_791058f8a5ff4e4bbb14a0a285a558ff","oldText":"Count number of occurrences of needle in haystack Has same signature as org.apache.commons.lang3.StringUtils#countMatches","tlText":"统计大海捞针的出现次数与org.apache. commons.lang3.StringUtils#countMatches相同签名","version":0},{"id":"t_50f5632c6d494135bcf84d55c8528455","oldText":"haystack - the CharSequence to check, may be null","tlText":"haystack -要检查的CharSequence，可能为空","version":0},{"id":"t_7c55d9e7aa8841c2a98a4ce2ddbbb4e5","oldText":"needle - the character to count the quantity of","tlText":"needle -计算数量的字符","version":0},{"id":"t_78a760a2001c4fb3a196aa854b55c235","oldText":"the number of occurrences, 0 if the CharSequence is null","tlText":"出现次数，如果CharSequence为空，则为0","version":0},{"id":"t_22c70b5982d24983b7aa893e8d88f3be","oldText":"Given a byte array of 16-bit unicode characters in Little Endian format (most important byte last), return a Java String representation of it. Scans the byte array for two continous 0 bytes and returns the string before. #61881: there seem to be programs out there, which write the 0-termination also at the beginning of the string. Check if the next two bytes contain a valid ascii char and correct the _recdata with a \u0027?\u0027 char","tlText":"给定Little Endian格式的16位Unicode字符的字节数组（最重要的字节最后），返回其Java字符串表示。扫描字节数组中的两个连续0字节并返回之前的字符串。#61881：似乎有一些程序，它们也在字符串的开头写入了0终止符。检查接下来的两个字节是否包含有效的asspel字符，并用\u0027？纠正_recdata \u0027查尔","version":0},{"id":"t_a518783671bf45898cbe6ee4cebf914e","oldText":"string - the byte array to be converted","tlText":"字符串-要转换的字节数组","version":0},{"id":"t_0abfde8793264edeab351d875ec5d23a","oldText":"offset - the initial offset into the byte array. it is assumed that string[ offset ] and string[ offset + 1 ] contain the first 16-bit unicode character","tlText":"Offset -字节数组的初始偏差。假设字符串[lock]和字符串[lock + 1 ]包含第一个16位Unicode字符","version":0},{"id":"t_1b541ec51024465987872115a79ddfd5","oldText":"len - the max. length of the final string","tlText":"len -最大值。最终字符串的长度","version":0},{"id":"t_3f0e0dca3721493e892c3a7ca6b01e34","oldText":"the converted string, never null.","tlText":"转换后的字符串，绝不能为空。","version":0},{"id":"t_92b2c868860542c58c01baeea80afb79","oldText":"java.lang.ArrayIndexOutOfBoundsException - if offset is out of bounds for the byte array (i.e., is negative or is greater than or equal to string.length)","tlText":"java.lang. ArrayIndexOutOfBoundsResponse-如果字节数组的偏差超出界限（即，为负或大于或等于字符串.长度）","version":0},{"id":"t_0cb28a7bb54c40a7baba9b7ce2d28099","oldText":"java.lang.IllegalArgumentException - if len is too large (i.e., there is not enough data in string to create a String of that length)","tlText":"Java.lang. IllegalArgumentExcept-如果len太大（即，字符串中没有足够的数据来创建该长度的字符串）","version":0}]