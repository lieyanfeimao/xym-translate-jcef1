[{"id":"t_86710c8512fc40b6adad7d416bbe7d5f","oldText":"The below classes implement support for routing aynchronous messages between JavaScript running in the renderer process and C++ running in the browser process. An application interacts with the router by passing it data from standard CEF C++ callbacks (OnBeforeBrowse, OnProcessMessageRecieved, OnContextCreated, etc). The renderer-side router supports generic JavaScript callback registration and execution while the browser-side router supports application-specific logic via one or more application-provided Handler instances. The renderer-side router implementation exposes a query function and a cancel function via the JavaScript \u0027window\u0027 object: // Create and send a new query. var request_id \u003d window.cefQuery({ request: \u0027my_request\u0027, persistent: false, onSuccess: function(response) {}, onFailure: function(error_code, error_message) {} }); // Optionally cancel the query. window.cefQueryCancel(request_id); When |window.cefQuery| is executed the request is sent asynchronously to one or more C++ Handler objects registered in the browser process. Each C++ Handler can choose to either handle or ignore the query in the Handler::OnQuery callback. If a Handler chooses to handle the query then it should execute Callback::Success when a response is available or Callback::Failure if an error occurs. This will result in asynchronous execution of the associated JavaScript callback in the renderer process. Any queries unhandled by C++ code in the browser process will be automatically canceled and the associated JavaScript onFailure callback will be executed with an error code of -1. Queries can be either persistent or non-persistent. If the query is persistent than the callbacks will remain registered until one of the following conditions are met: A. The query is canceled in JavaScript using the |window.cefQueryCancel| function. B. The query is canceled in C++ code using the Callback::Failure function. C. The context associated with the query is released due to browser destruction, navigation or renderer process termination. If the query is non-persistent then the registration will be removed after the JavaScript callback is executed a single time. If a query is canceled for a reason other than Callback::Failure being executed then the associated Handler\u0027s OnQueryCanceled method will be called. Some possible usage patterns include: One-time Request. Use a non-persistent query to send a JavaScript request. The Handler evaluates the request and returns the response. The query is then discarded. Broadcast. Use a persistent query to register as a JavaScript broadcast receiver. The Handler keeps track of all registered Callbacks and executes them sequentially to deliver the broadcast message. Subscription. Use a persistent query to register as a JavaScript subscription receiver. The Handler initiates the subscription feed on the first request and delivers responses to all registered subscribers as they become available. The Handler cancels the subscription feed when there are no longer any registered JavaScript receivers. Message routing occurs on a per-browser and per-context basis. Consequently, additional application logic can be applied by restricting which browser or context instances are passed into the router. If you choose to use this approach do so cautiously. In order for the router to function correctly any browser or context instance passed into a single router callback must then be passed into all router callbacks. There is generally no need to have multiple renderer-side routers unless you wish to have multiple bindings with different JavaScript function names. It can be useful to have multiple browser-side routers with different client- provided Handler instances when implementing different behaviors on a per- browser basis. This implementation places no formatting restrictions on payload content. An application may choose to exchange anything from simple formatted strings to serialized XML or JSON data. EXAMPLE USAGE 1. Define the router configuration. You can optionally specify settings like the JavaScript function names. The configuration must be the same in both the browser and renderer processes. If using multiple routers in the same application make sure to specify unique function names for each router configuration. // Example config object showing the default values. CefMessageRouterConfig config \u003d new CefMessageRouterConfig(); config.jsQueryFunction \u003d \"cefQuery\"; config.jsCancelFunction \u003d \"cefQueryCancel\"; 2. Create an instance of CefMessageRouter in the browser process. messageRouter_ \u003d CefMessageRouter.create(config); 3. Register one or more Handlers. The Handler instances must either outlive the router or be removed from the router before they\u0027re deleted. messageRouter_.addHandler(myHandler); 4. Add your message router to all CefClient instances you want to get your JavaScript code be handled. myClient.addMessageRouter(messageRouter_); 4. Execute the query function from JavaScript code. window.cefQuery({request: \u0027my_request\u0027, persistent: false, onSuccess: function(response) { print(response); }, onFailure: function(error_code, error_message) {} }); 5. Handle the query in your CefMessageRouterHandler.onQuery implementation and execute the appropriate callback either immediately or asynchronously. public boolean onQuery(CefBrowser browser, long query_id, String request, boolean persistent, CefQueryCallback callback) { if (request.indexOf(\"my_request\") \u003d\u003d 0) { callback.success(\"my_response\"); return true; } return false; // Not handled. } 6. Notice that the success callback is executed in JavaScript.","tlText":"下面的类实现了对在渲染进程中运行的JavaScript和在浏览器进程中运行的c++之间路由异步消息的支持。\u003cbr\u003e\n应用程序通过从标准CEF c++回调(OnBeforeBrowse, onprocessmessagerreceived, OnContextCreated等)中传递数据来与路由器进行交互。\u003cbr\u003e\n渲染器端路由器支持通用的JavaScript回调注册和执行，而浏览器端路由器通过一个或多个应用程序提供的Handler实例来支持特定于应用程序的逻辑。\u003cbr\u003e\n渲染端的路由器通过实现JavaScript的“window”对象公开了一个查询函数和一个取消函数：\u003cbr\u003e\n//创建并发送一个新查询。\u003cbr\u003e\nvar request_id\u003dwindow.cefQuery({\u003cbr\u003e\nrequest:\u0027my_request\u0027,\u003cbr\u003e\npersistent:false,\u003cbr\u003e\nonSuccess:function(response){},\u003cbr\u003e\nonFailure:function(error_code,error_message){}\u003cbr\u003e\n});\u003cbr\u003e\n//您可以取消查询。\u003cbr\u003e\nwindow.cefQueryCancel(request_id);\u003cbr\u003e\n当|window.cefQuery|被执行时，请求被异步发送到一个或多个在浏览器进程中注册的c++ Handler对象，每个c++ Handler都可以选择处理或忽略Handler::OnQuery回调中的查询。\u003cbr\u003e\n如果Handler选择处理查询，那么当有响应可用时，它执行Callback::Success;如果发生错误，它执行Callback::Failure。\u003cbr\u003e\n这将导致在渲染器进程中异步执行相关的JavaScript回调。\u003cbr\u003e\n在浏览器进程中，任何未被c++代码处理的查询将被自动取消，相关的JavaScript onFailure回调将被执行，错误码为-1。\u003cbr\u003e\n查询可以是持久的，也可以是非持久的。\u003cbr\u003e\n如果查询是持久的，则回调将保持注册状态，直到满足以下条件之一:\u003cbr\u003e\nA.在JavaScript中使用|window. cefQueryCancel|函数取消查询。\u003cbr\u003e\nB.在c++代码中使用Callback::Failure函数取消查询。\u003cbr\u003e\nC.浏览器销毁、导航或渲染进程终止，与查询关联的上下文被释放。\u003cbr\u003e\n如果查询是非持久化的，那么在JavaScript回调执行一次后，注册将被删除。\u003cbr\u003e\n如果一个查询因为Callback::Failure之外的原因被取消，那么关联的Handler的OnQueryCanceled方法将被调用。\u003cbr\u003e\n一些可能的使用模式包括:一次性请求。\u003cbr\u003e\n使用非持久性查询发送JavaScript请求，处理程序计算请求并返回响应，然后丢弃该查询。\u003cbr\u003e\n\u003cb\u003e广播\u003c/b\u003e\u003cbr\u003e\n将持久查询注册为JavaScript广播接收器，Handler跟踪所有已注册的回调，并依次执行它们以传递广播消息。\u003cbr\u003e\n\u003cb\u003e订阅\u003c/b\u003e\u003cbr\u003e\n将持久查询注册为JavaScript订阅接收方。Handler在第一个请求时启动订阅源，并在所有注册订阅者可用时将响应传递给他们。当不再有任何已注册的JavaScript接收器时，处理程序将取消订阅源。\u003cbr\u003e\n消息路由发生在每个浏览器和每个上下文的基础上。因此，可以通过限制哪些浏览器或上下文实例被传递到路由器来应用额外的应用逻辑。\u003cbr\u003e\n如果您选择使用这种方法，请谨慎使用。为了使路由器正常工作，任何传入单个路由器回调函数的浏览器或上下文实例都必须传入所有路由器回调函数。\u003cbr\u003e\n通常不需要有多个渲染器端路由器，除非你希望有多个具有不同JavaScript函数名的绑定。\u003cbr\u003e\n当在每个浏览器的基础上实现不同的行为时，使用多个不同客户端提供的Handler实例的浏览器端路由器是很有用的。\u003cbr\u003e\n此实现对内容没有格式化限制，应用程序可以选择交换任何东西，从简单的格式化字符串到序列化的XML或JSON数据。\u003cbr\u003e\n\u003cb\u003e示例使用\u003c/b\u003e\u003cbr\u003e\n1. 定义路由器配置。您可以指定JavaScript函数名，浏览器和渲染程序进程中的配置必须相同。如果在同一个应用程序中使用多个路由器，请确保为每个路由器配置指定唯一的函数名。\u003cbr\u003e\n//示例配置对象显示默认值。\u003cbr\u003e\nCefMessageRouterConfig config \u003d new CefMessageRouterConfig();      \u003cbr\u003e\nconfig.jsQueryFunction \u003d \"cefQuery\";\u003cbr\u003e\nconfig.jsCancelFunction \u003d \"cefQueryCancel\";\u003cbr\u003e\n2.在浏览器进程中创建CefMessageRouter的实例。\u003cbr\u003e\nmessageRouter_ \u003d CefMessageRouter.create(config);\u003cbr\u003e\n3.注册一个或多个处理程序。Handler实例必须活得比CefMessageRouter实例长，在删除Handler实例之前请先从CefMessageRouter实例中将其删除。\u003cbr\u003e\nmessageRouter_.addHandler(myHandler);\u003cbr\u003e\n4.将您的消息路由器添加到您希望处理JavaScript代码的所有CefClient实例中。\u003cbr\u003e\nmyClient.addMessageRouter(messageRouter_);\u003cbr\u003e\n5.从JavaScript代码执行查询函数。\u003cbr\u003e\nwindow. cefQuery({\u003cbr\u003e\nrequest: \u0027my_request\u0027, \u003cbr\u003e\npersistent: false, \u003cbr\u003e\nonSuccess: function(response) { print(response);        }, \u003cbr\u003e\nonFailure: function(error_code, error_message) {} \u003cbr\u003e\n});\u003cbr\u003e\n6.在CefMessageRouterHandler.onQuery的实现中处理查询，并立即或异步执行适当的回调。 \u003cbr\u003e\npublic boolean onQuery(CefBrowser browser, long query_id, String request, boolean persistent, CefQueryCallback callback) {  \u003cbr\u003e\nif (request.indexOf(\"my_request\") \u003d\u003d 0) {  \u003cbr\u003e\ncallback.success(\"my_response\");            \u003cbr\u003e\nreturn true;            \u003cbr\u003e\n}  \u003cbr\u003e\nreturn false;            \u003cbr\u003e\n// Not handled. \u003cbr\u003e\n} \u003cbr\u003e\n7.请注意，成功回调是用JavaScript执行的。","version":0},{"id":"t_9904adbd210746a7bb587f246e203866","oldText":"Used to configure the query router.","tlText":"用于配置查询路由器。","version":0},{"id":"t_e13066266f83465da3b32d2f660a9cb2","oldText":"Add a new query handler.","tlText":"添加新的查询处理程序。","version":0},{"id":"t_ef5a6433b2764bf2beca13638e88012e","oldText":"Cancel all pending queries associated with either |browser| or |handler|.","tlText":"取消所有与|browser|或|handler|关联的挂起查询。","version":0},{"id":"t_dd58b6c04b2a4e5e9d1699aa5c2d25ec","oldText":"Create a new router with the default configuration.","tlText":"使用默认配置创建一个新路由器。","version":0},{"id":"t_dff070ec69fe4325b3a15589c0a456f4","oldText":"Create a new router with the specified configuration.","tlText":"使用指定的配置创建一个新路由器。","version":0},{"id":"t_4cf5f3b148cb4875adad66ce2838507c","oldText":"Create a new router with the specified handler and configuration.","tlText":"使用指定的处理程序和配置创建一个新路由器。","version":0},{"id":"t_efc12ad864b040f6a451fa49bfda81d4","oldText":"Create a new router with the specified handler and default configuration.","tlText":"使用指定的处理程序和默认配置创建一个新路由器。","version":0},{"id":"t_ef5c0cbffe834a2896e4346cdf91093e","oldText":"Must be called if the CefMessageRouter instance isn\u0027t used any more.","tlText":"如果不再使用CefMessageRouter实例，则必须调用。","version":0},{"id":"t_89e2789eaa04466581b531f8dc01e345","oldText":"Remove an existing query handler.","tlText":"删除现有的查询处理程序。","version":0},{"id":"t_9268b4cd6fd64f728c9a3e18cfa76313","oldText":"Add a new query handler.","tlText":"添加新的查询处理程序。","version":0},{"id":"t_09211bc49d184446acb1edbe7c2a757e","oldText":"handler - The handler to be added.","tlText":"handler-要添加的处理程序。","version":0},{"id":"t_f09d5194f1724264a7752f20a47342b2","oldText":"first - If true the handler will be added as the first handler, otherwise it will be added as the last handler.","tlText":"first-如果为true，则处理程序将作为第一个处理程序添加，否则将作为最后一个处理程序进行添加。","version":0},{"id":"t_46259e163e70423686e2bd12ca26eb0f","oldText":"True if the handler is added successfully.","tlText":"如果成功添加处理程序，则为True。","version":0},{"id":"t_c3a1d9340a5d4646849100ebeb793522","oldText":"Cancel all pending queries associated with either |browser| or |handler|. If both |browser| and |handler| are NULL all pending queries will be canceled. onQueryCanceled will be called and the associated JavaScript onFailure callback will be executed in all cases with an error code of -1.","tlText":"取消所有与|browser|或|handler|关联的挂起查询。如果|browser|和|handler|都为NULL，则所有挂起的查询都将被取消。onQueryCanceled将被调用，并且在所有情况下都将执行相关的JavaScript onFailure回调，错误代码为-1。","version":0},{"id":"t_e18ff4bc965846d692174e674b3c8914","oldText":"browser - The associated browser, or null.","tlText":"browser-关联的浏览器，或null。","version":0},{"id":"t_ec383bf53dae4f2c87e188bfa13f4335","oldText":"handler - The associated handler, or null.","tlText":"handler-关联的处理程序，或null。","version":0},{"id":"t_fdcf02d396524adf88828f14415797b1","oldText":"Create a new router with the default configuration. The addHandler() method should be called to add a handler.","tlText":"使用默认配置创建一个新路由器。应该调用addHandler()方法来添加处理程序。","version":0},{"id":"t_fa79ebe6a0794d90acd0a1ea79a74e4f","oldText":"Create a new router with the specified configuration. The addHandler() method should be called to add a handler.","tlText":"使用指定的配置创建一个新路由器。应该调用addHandler()方法来添加处理程序。","version":0},{"id":"t_44d6b313633441e2a8813095f6a8e0ce","oldText":"Create a new router with the specified handler and configuration.","tlText":"使用指定的处理程序和配置创建一个新路由器。","version":0},{"id":"t_7a01f865251749469106e8247a27d1e2","oldText":"Create a new router with the specified handler and default configuration.","tlText":"使用指定的处理程序和默认配置创建一个新路由器。","version":0},{"id":"t_7c0efb91b73342718abd64ce1ca09ce4","oldText":"Must be called if the CefMessageRouter instance isn\u0027t used any more.","tlText":"如果不再使用CefMessageRouter实例，则必须调用。","version":0},{"id":"t_b3f283b73e1d41daaeddfe149790963f","oldText":"java.lang.Throwable","tlText":"java.lang.Throwable","version":0},{"id":"t_325a0b09b73348bcaf62a5d6ee412f47","oldText":"Remove an existing query handler. Any pending queries associated with the handler will be canceled. onQueryCanceled will be called and the associated JavaScript onFailure callback will be executed with an error code of -1.","tlText":"删除现有的查询处理程序。任何与处理程序关联的挂起查询都将被取消。onQueryCanceled将被调用，相关的JavaScript onFailure回调将被执行，错误代码为-1。","version":0},{"id":"t_fe676f40bf1042489fa8aac384960c10","oldText":"handler - The handler to be removed.","tlText":"handler-要删除的处理程序。","version":0},{"id":"t_3ef603e33c5c4840b2dd8b39c4c851be","oldText":"True if the handler is removed successfully.","tlText":"如果处理程序已成功删除，则为True。","version":0}]